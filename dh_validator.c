/* dh_validator.c generated by valac 0.56.3, the Vala compiler
 * generated from dh_validator.vala, do not modify */

#include <stdlib.h>
#include <string.h>
#include <glib.h>
#include <glib-object.h>
#include <float.h>
#include <math.h>
#include <glib/gi18n-lib.h>
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>
#include <errno.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

typedef gchar* (*DhLineinFunc) (const gchar* prompt, gpointer user_data);

#define TYPE_DH_VALIDATOR (dh_validator_get_type ())
#define DH_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_VALIDATOR, DhValidator))
#define IS_DH_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_VALIDATOR))
#define DH_VALIDATOR_GET_INTERFACE(obj) (G_TYPE_INSTANCE_GET_INTERFACE ((obj), TYPE_DH_VALIDATOR, DhValidatorIface))

typedef struct _DhValidator DhValidator;
typedef struct _DhValidatorIface DhValidatorIface;

#define TYPE_DH_INT_VALIDATOR (dh_int_validator_get_type ())
#define DH_INT_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_INT_VALIDATOR, DhIntValidator))
#define DH_INT_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DH_INT_VALIDATOR, DhIntValidatorClass))
#define IS_DH_INT_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_INT_VALIDATOR))
#define IS_DH_INT_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DH_INT_VALIDATOR))
#define DH_INT_VALIDATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DH_INT_VALIDATOR, DhIntValidatorClass))

typedef struct _DhIntValidator DhIntValidator;
typedef struct _DhIntValidatorClass DhIntValidatorClass;
typedef struct _DhIntValidatorPrivate DhIntValidatorPrivate;
enum  {
	DH_INT_VALIDATOR_0_PROPERTY,
	DH_INT_VALIDATOR_NUM_PROPERTIES
};
static GParamSpec* dh_int_validator_properties[DH_INT_VALIDATOR_NUM_PROPERTIES];

#define TYPE_DH_UINT_VALIDATOR (dh_uint_validator_get_type ())
#define DH_UINT_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_UINT_VALIDATOR, DhUIntValidator))
#define DH_UINT_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DH_UINT_VALIDATOR, DhUIntValidatorClass))
#define IS_DH_UINT_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_UINT_VALIDATOR))
#define IS_DH_UINT_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DH_UINT_VALIDATOR))
#define DH_UINT_VALIDATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DH_UINT_VALIDATOR, DhUIntValidatorClass))

typedef struct _DhUIntValidator DhUIntValidator;
typedef struct _DhUIntValidatorClass DhUIntValidatorClass;
typedef struct _DhUIntValidatorPrivate DhUIntValidatorPrivate;
enum  {
	DH_UINT_VALIDATOR_0_PROPERTY,
	DH_UINT_VALIDATOR_NUM_PROPERTIES
};
static GParamSpec* dh_uint_validator_properties[DH_UINT_VALIDATOR_NUM_PROPERTIES];

#define TYPE_DH_DOUBLE_VALIDATOR (dh_double_validator_get_type ())
#define DH_DOUBLE_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_DOUBLE_VALIDATOR, DhDoubleValidator))
#define DH_DOUBLE_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DH_DOUBLE_VALIDATOR, DhDoubleValidatorClass))
#define IS_DH_DOUBLE_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_DOUBLE_VALIDATOR))
#define IS_DH_DOUBLE_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DH_DOUBLE_VALIDATOR))
#define DH_DOUBLE_VALIDATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DH_DOUBLE_VALIDATOR, DhDoubleValidatorClass))

typedef struct _DhDoubleValidator DhDoubleValidator;
typedef struct _DhDoubleValidatorClass DhDoubleValidatorClass;
typedef struct _DhDoubleValidatorPrivate DhDoubleValidatorPrivate;
enum  {
	DH_DOUBLE_VALIDATOR_0_PROPERTY,
	DH_DOUBLE_VALIDATOR_NUM_PROPERTIES
};
static GParamSpec* dh_double_validator_properties[DH_DOUBLE_VALIDATOR_NUM_PROPERTIES];

#define TYPE_DH_REGEX_VALIDATOR (dh_regex_validator_get_type ())
#define DH_REGEX_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_REGEX_VALIDATOR, DhRegexValidator))
#define DH_REGEX_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DH_REGEX_VALIDATOR, DhRegexValidatorClass))
#define IS_DH_REGEX_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_REGEX_VALIDATOR))
#define IS_DH_REGEX_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DH_REGEX_VALIDATOR))
#define DH_REGEX_VALIDATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DH_REGEX_VALIDATOR, DhRegexValidatorClass))

typedef struct _DhRegexValidator DhRegexValidator;
typedef struct _DhRegexValidatorClass DhRegexValidatorClass;
typedef struct _DhRegexValidatorPrivate DhRegexValidatorPrivate;
enum  {
	DH_REGEX_VALIDATOR_0_PROPERTY,
	DH_REGEX_VALIDATOR_NUM_PROPERTIES
};
static GParamSpec* dh_regex_validator_properties[DH_REGEX_VALIDATOR_NUM_PROPERTIES];
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

#define TYPE_DH_MATCH_VALIDATOR (dh_match_validator_get_type ())
#define DH_MATCH_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_MATCH_VALIDATOR, DhMatchValidator))
#define DH_MATCH_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DH_MATCH_VALIDATOR, DhMatchValidatorClass))
#define IS_DH_MATCH_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_MATCH_VALIDATOR))
#define IS_DH_MATCH_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DH_MATCH_VALIDATOR))
#define DH_MATCH_VALIDATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DH_MATCH_VALIDATOR, DhMatchValidatorClass))

typedef struct _DhMatchValidator DhMatchValidator;
typedef struct _DhMatchValidatorClass DhMatchValidatorClass;
typedef struct _DhMatchValidatorPrivate DhMatchValidatorPrivate;
enum  {
	DH_MATCH_VALIDATOR_0_PROPERTY,
	DH_MATCH_VALIDATOR_NUM_PROPERTIES
};
static GParamSpec* dh_match_validator_properties[DH_MATCH_VALIDATOR_NUM_PROPERTIES];
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_DH_INT_ARRAY_VALIDATOR (dh_int_array_validator_get_type ())
#define DH_INT_ARRAY_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_INT_ARRAY_VALIDATOR, DhIntArrayValidator))
#define DH_INT_ARRAY_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DH_INT_ARRAY_VALIDATOR, DhIntArrayValidatorClass))
#define IS_DH_INT_ARRAY_VALIDATOR(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_INT_ARRAY_VALIDATOR))
#define IS_DH_INT_ARRAY_VALIDATOR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DH_INT_ARRAY_VALIDATOR))
#define DH_INT_ARRAY_VALIDATOR_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DH_INT_ARRAY_VALIDATOR, DhIntArrayValidatorClass))

typedef struct _DhIntArrayValidator DhIntArrayValidator;
typedef struct _DhIntArrayValidatorClass DhIntArrayValidatorClass;
typedef struct _DhIntArrayValidatorPrivate DhIntArrayValidatorPrivate;
enum  {
	DH_INT_ARRAY_VALIDATOR_0_PROPERTY,
	DH_INT_ARRAY_VALIDATOR_NUM_PROPERTIES
};
static GParamSpec* dh_int_array_validator_properties[DH_INT_ARRAY_VALIDATOR_NUM_PROPERTIES];

#define TYPE_DH_ARG_INFO (dh_arg_info_get_type ())
#define DH_ARG_INFO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_ARG_INFO, DhArgInfo))
#define DH_ARG_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DH_ARG_INFO, DhArgInfoClass))
#define IS_DH_ARG_INFO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_ARG_INFO))
#define IS_DH_ARG_INFO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DH_ARG_INFO))
#define DH_ARG_INFO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DH_ARG_INFO, DhArgInfoClass))

typedef struct _DhArgInfo DhArgInfo;
typedef struct _DhArgInfoClass DhArgInfoClass;
typedef struct _DhArgInfoPrivate DhArgInfoPrivate;
enum  {
	DH_ARG_INFO_0_PROPERTY,
	DH_ARG_INFO_NUM_PROPERTIES
};
static GParamSpec* dh_arg_info_properties[DH_ARG_INFO_NUM_PROPERTIES];

#define TYPE_DH_OUT (dh_out_get_type ())
#define DH_OUT(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_DH_OUT, DhOut))
#define DH_OUT_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_DH_OUT, DhOutClass))
#define IS_DH_OUT(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_DH_OUT))
#define IS_DH_OUT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_DH_OUT))
#define DH_OUT_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_DH_OUT, DhOutClass))

typedef struct _DhOut DhOut;
typedef struct _DhOutClass DhOutClass;
typedef struct _DhOutPrivate DhOutPrivate;
enum  {
	DH_OUT_0_PROPERTY,
	DH_OUT_NUM_PROPERTIES
};
static GParamSpec* dh_out_properties[DH_OUT_NUM_PROPERTIES];
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
enum  {
	DH_OUT_SIG_EOF_SIGNAL,
	DH_OUT_NUM_SIGNALS
};
static guint dh_out_signals[DH_OUT_NUM_SIGNALS] = {0};

struct _DhValidatorIface {
	GTypeInterface parent_iface;
	gboolean (*in_field) (DhValidator* self, gconstpointer val);
	void (*set_range) (DhValidator* self, gconstpointer min_val, gconstpointer max_val);
};

struct _DhIntValidator {
	GObject parent_instance;
	DhIntValidatorPrivate * priv;
};

struct _DhIntValidatorClass {
	GObjectClass parent_class;
};

struct _DhIntValidatorPrivate {
	gint64 min;
	gint64 max;
	gboolean ignore;
};

struct _DhUIntValidator {
	GObject parent_instance;
	DhUIntValidatorPrivate * priv;
};

struct _DhUIntValidatorClass {
	GObjectClass parent_class;
};

struct _DhUIntValidatorPrivate {
	guint64 min;
	guint64 max;
	gboolean ignore;
};

struct _DhDoubleValidator {
	GObject parent_instance;
	DhDoubleValidatorPrivate * priv;
};

struct _DhDoubleValidatorClass {
	GObjectClass parent_class;
};

struct _DhDoubleValidatorPrivate {
	gdouble min;
	gdouble max;
	gboolean ignore;
};

struct _DhRegexValidator {
	GObject parent_instance;
	DhRegexValidatorPrivate * priv;
};

struct _DhRegexValidatorClass {
	GObjectClass parent_class;
};

struct _DhRegexValidatorPrivate {
	GRegex* reg;
};

struct _DhMatchValidator {
	GObject parent_instance;
	DhMatchValidatorPrivate * priv;
};

struct _DhMatchValidatorClass {
	GObjectClass parent_class;
};

struct _DhMatchValidatorPrivate {
	gchar* match_str;
	gboolean ignore;
};

struct _DhIntArrayValidator {
	GObject parent_instance;
	DhIntArrayValidatorPrivate * priv;
	gchar* split_str;
};

struct _DhIntArrayValidatorClass {
	GObjectClass parent_class;
};

struct _DhIntArrayValidatorPrivate {
	GList* min;
	GList* max;
	gboolean allow_repeated;
	gboolean ignore;
};

struct _DhArgInfo {
	GObject parent_instance;
	DhArgInfoPrivate * priv;
	GList* arg;
	GList* arg_fullname;
	GList* description;
};

struct _DhArgInfoClass {
	GObjectClass parent_class;
};

struct _DhArgInfoPrivate {
	gchar default_arg;
};

struct _DhOut {
	GObject parent_instance;
	DhOutPrivate * priv;
};

struct _DhOutClass {
	GObjectClass parent_class;
};

struct _DhOutPrivate {
	gboolean match_string;
	gboolean output_str_while_nov;
	gboolean show_opt;
};

static gint DhIntValidator_private_offset;
static gpointer dh_int_validator_parent_class = NULL;
static DhValidatorIface * dh_int_validator_dh_validator_parent_iface = NULL;
static gint DhUIntValidator_private_offset;
static gpointer dh_uint_validator_parent_class = NULL;
static DhValidatorIface * dh_uint_validator_dh_validator_parent_iface = NULL;
static gint DhDoubleValidator_private_offset;
static gpointer dh_double_validator_parent_class = NULL;
static DhValidatorIface * dh_double_validator_dh_validator_parent_iface = NULL;
static gint DhRegexValidator_private_offset;
static gpointer dh_regex_validator_parent_class = NULL;
static DhValidatorIface * dh_regex_validator_dh_validator_parent_iface = NULL;
static gint DhMatchValidator_private_offset;
static gpointer dh_match_validator_parent_class = NULL;
static DhValidatorIface * dh_match_validator_dh_validator_parent_iface = NULL;
static gint DhIntArrayValidator_private_offset;
static gpointer dh_int_array_validator_parent_class = NULL;
static DhValidatorIface * dh_int_array_validator_dh_validator_parent_iface = NULL;
static gint DhArgInfo_private_offset;
static gpointer dh_arg_info_parent_class = NULL;
static gint DhOut_private_offset;
static gpointer dh_out_parent_class = NULL;
static DhArgInfo* dh_out_info;
static DhArgInfo* dh_out_info = NULL;

VALA_EXTERN GType dh_validator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhValidator, g_object_unref)
VALA_EXTERN gboolean dh_validator_in_field (DhValidator* self,
                                gconstpointer val);
VALA_EXTERN void dh_validator_set_range (DhValidator* self,
                             gconstpointer min_val,
                             gconstpointer max_val);
static GType dh_validator_get_type_once (void);
VALA_EXTERN GType dh_int_validator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhIntValidator, g_object_unref)
VALA_EXTERN DhIntValidator* dh_int_validator_new_ignore_range (gboolean ir);
VALA_EXTERN DhIntValidator* dh_int_validator_construct_ignore_range (GType object_type,
                                                         gboolean ir);
VALA_EXTERN DhIntValidator* dh_int_validator_new (gint64 min,
                                      gint64 max);
VALA_EXTERN DhIntValidator* dh_int_validator_construct (GType object_type,
                                            gint64 min,
                                            gint64 max);
static gboolean dh_int_validator_real_in_field (DhValidator* base,
                                         gint64* val);
static void dh_int_validator_real_set_range (DhValidator* base,
                                      gint64* min_val,
                                      gint64* max_val);
static void dh_int_validator_finalize (GObject * obj);
static GType dh_int_validator_get_type_once (void);
VALA_EXTERN GType dh_uint_validator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhUIntValidator, g_object_unref)
VALA_EXTERN DhUIntValidator* dh_uint_validator_new_ignore_range (gboolean ir);
VALA_EXTERN DhUIntValidator* dh_uint_validator_construct_ignore_range (GType object_type,
                                                           gboolean ir);
VALA_EXTERN DhUIntValidator* dh_uint_validator_new (guint64 min,
                                        guint64 max);
VALA_EXTERN DhUIntValidator* dh_uint_validator_construct (GType object_type,
                                              guint64 min,
                                              guint64 max);
static gboolean dh_uint_validator_real_in_field (DhValidator* base,
                                          guint64* val);
static void dh_uint_validator_real_set_range (DhValidator* base,
                                       guint64* min_val,
                                       guint64* max_val);
static void dh_uint_validator_finalize (GObject * obj);
static GType dh_uint_validator_get_type_once (void);
VALA_EXTERN GType dh_double_validator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhDoubleValidator, g_object_unref)
VALA_EXTERN DhDoubleValidator* dh_double_validator_new_ignore_range (gboolean ir);
VALA_EXTERN DhDoubleValidator* dh_double_validator_construct_ignore_range (GType object_type,
                                                               gboolean ir);
VALA_EXTERN DhDoubleValidator* dh_double_validator_new (gdouble min,
                                            gdouble max);
VALA_EXTERN DhDoubleValidator* dh_double_validator_construct (GType object_type,
                                                  gdouble min,
                                                  gdouble max);
static gboolean dh_double_validator_real_in_field (DhValidator* base,
                                            gdouble* val);
static void dh_double_validator_real_set_range (DhValidator* base,
                                         gdouble* min_val,
                                         gdouble* max_val);
static void dh_double_validator_finalize (GObject * obj);
static GType dh_double_validator_get_type_once (void);
VALA_EXTERN GType dh_regex_validator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhRegexValidator, g_object_unref)
VALA_EXTERN DhRegexValidator* dh_regex_validator_new (GRegex* r);
VALA_EXTERN DhRegexValidator* dh_regex_validator_construct (GType object_type,
                                                GRegex* r);
static gboolean dh_regex_validator_real_in_field (DhValidator* base,
                                           const gchar* val);
static void dh_regex_validator_real_set_range (DhValidator* base,
                                        GRegex* min_val,
                                        GRegex* max_val);
static void dh_regex_validator_finalize (GObject * obj);
static GType dh_regex_validator_get_type_once (void);
VALA_EXTERN GType dh_match_validator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhMatchValidator, g_object_unref)
VALA_EXTERN DhMatchValidator* dh_match_validator_new_ignore_range (gboolean ir);
VALA_EXTERN DhMatchValidator* dh_match_validator_construct_ignore_range (GType object_type,
                                                             gboolean ir);
VALA_EXTERN DhMatchValidator* dh_match_validator_new (const gchar* str);
VALA_EXTERN DhMatchValidator* dh_match_validator_construct (GType object_type,
                                                const gchar* str);
static gboolean dh_match_validator_real_in_field (DhValidator* base,
                                           const gchar* val);
static void dh_match_validator_real_set_range (DhValidator* base,
                                        const gchar* min_val,
                                        const gchar* max_val);
static void dh_match_validator_finalize (GObject * obj);
static GType dh_match_validator_get_type_once (void);
VALA_EXTERN GType dh_int_array_validator_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhIntArrayValidator, g_object_unref)
static void _g_free0_ (gpointer var);
static inline void _g_list_free__g_free0_ (GList* self);
VALA_EXTERN DhIntArrayValidator* dh_int_array_validator_new_ignore_range (gboolean ir);
VALA_EXTERN DhIntArrayValidator* dh_int_array_validator_construct_ignore_range (GType object_type,
                                                                    gboolean ir);
static gboolean dh_int_array_validator_real_in_field (DhValidator* base,
                                               GList* val);
static void dh_int_array_validator_real_set_range (DhValidator* base,
                                            GList* min_val,
                                            GList* max_val);
VALA_EXTERN void dh_int_array_validator_add_range (DhIntArrayValidator* self,
                                       gint64 min_val,
                                       gint64 max_val);
static gint64* _int64_dup (gint64* self);
VALA_EXTERN void dh_int_array_validator_set_split_str (DhIntArrayValidator* self,
                                           const gchar* sp_str);
VALA_EXTERN void dh_int_array_validator_set_allow_repeated (DhIntArrayValidator* self,
                                                gboolean ar);
VALA_EXTERN DhIntArrayValidator* dh_int_array_validator_new (void);
VALA_EXTERN DhIntArrayValidator* dh_int_array_validator_construct (GType object_type);
static void dh_int_array_validator_finalize (GObject * obj);
static GType dh_int_array_validator_get_type_once (void);
VALA_EXTERN GType dh_arg_info_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhArgInfo, g_object_unref)
VALA_EXTERN void dh_arg_info_add_arg (DhArgInfo* self,
                          gchar new_arg,
                          const gchar* new_arg_fullname,
                          const gchar* new_description);
VALA_EXTERN gchar* dh_arg_info_help_message (DhArgInfo* self,
                                 const gchar* gettext_package);
VALA_EXTERN gchar dh_arg_info_match_char (DhArgInfo* self,
                              const gchar* str);
VALA_EXTERN gchar* dh_arg_info_match_string (DhArgInfo* self,
                                 const gchar* str);
VALA_EXTERN void dh_arg_info_change_default_arg (DhArgInfo* self,
                                     gchar arg);
VALA_EXTERN DhArgInfo* dh_arg_info_new (void);
VALA_EXTERN DhArgInfo* dh_arg_info_construct (GType object_type);
static void dh_arg_info_finalize (GObject * obj);
static GType dh_arg_info_get_type_once (void);
VALA_EXTERN GType dh_out_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (DhOut, g_object_unref)
static void dh_out_init_readline (DhOut* self);
static gchar** dh_out_dhutil_completion (const gchar* str,
                                  gint a,
                                  gint b,
                                  gint* result_length1);
static gchar** _dh_out_dhutil_completion_rl_completion_func_t (const gchar* str,
                                                        gint a,
                                                        gint b);
static gchar* dh_out_get_opt (DhOut* self,
                       DhArgInfo* arg);
VALA_EXTERN void dh_out_set_show_opt (DhOut* self,
                          gboolean option);
VALA_EXTERN void dh_out_no_output_string_while_no_validator (DhOut* self);
static gchar* dh_out_dhutil_compeuntry_func_static (const gchar* str,
                                             gint state);
static gchar* _dh_out_dhutil_compeuntry_func_static_rl_compentry_func_t (const gchar* str,
                                                                  gint a);
static gchar** _vala_array_dup1 (gchar** self,
                          gssize length);
VALA_EXTERN void dh_out_output_match_string_than_arg (DhOut* self);
static gchar* dh_out_dhutil_compeuntry_func (const gchar* str,
                                      gint state);
VALA_EXTERN void dh_out_read_and_output (DhOut* self,
                             const gchar* tip_message,
                             const gchar* gettext_package,
                             DhArgInfo* arg,
                             DhValidator* validator,
                             gboolean get_array,
                             GValue* result);
VALA_EXTERN void dh_out_read_and_output_custom (DhOut* self,
                                    DhLineinFunc func,
                                    gpointer func_target,
                                    const gchar* tip_message,
                                    const gchar* gettext_package,
                                    DhArgInfo* arg,
                                    DhValidator* validator,
                                    gboolean get_array,
                                    gboolean use_readline,
                                    GValue* result);
static gchar* dh_out_remove_blank (DhOut* self,
                            const gchar* str);
VALA_EXTERN void dh_out_read_and_output_as_int_custom (DhOut* self,
                                           DhLineinFunc func,
                                           gpointer func_target,
                                           const gchar* tip_message,
                                           const gchar* gettext_package,
                                           DhArgInfo* arg,
                                           gint64 min,
                                           gint64 max,
                                           gboolean get_array,
                                           gboolean use_readline,
                                           GValue* result);
VALA_EXTERN void dh_out_read_and_output_as_int (DhOut* self,
                                    const gchar* tip_message,
                                    const gchar* gettext_package,
                                    DhArgInfo* arg,
                                    gint64 min,
                                    gint64 max,
                                    gboolean get_array,
                                    GValue* result);
VALA_EXTERN DhOut* dh_out_new (void);
VALA_EXTERN DhOut* dh_out_construct (GType object_type);
static void dh_out_finalize (GObject * obj);
static GType dh_out_get_type_once (void);
static void _vala_array_destroy (gpointer array,
                          gssize array_length,
                          GDestroyNotify destroy_func);
static void _vala_array_free (gpointer array,
                       gssize array_length,
                       GDestroyNotify destroy_func);
static gssize _vala_array_length (gpointer array);

gboolean
dh_validator_in_field (DhValidator* self,
                       gconstpointer val)
{
	DhValidatorIface* _iface_;
	g_return_val_if_fail (self != NULL, FALSE);
	_iface_ = DH_VALIDATOR_GET_INTERFACE (self);
	if (_iface_->in_field) {
		return _iface_->in_field (self, val);
	}
	return FALSE;
}

void
dh_validator_set_range (DhValidator* self,
                        gconstpointer min_val,
                        gconstpointer max_val)
{
	DhValidatorIface* _iface_;
	g_return_if_fail (self != NULL);
	_iface_ = DH_VALIDATOR_GET_INTERFACE (self);
	if (_iface_->set_range) {
		_iface_->set_range (self, min_val, max_val);
	}
}

static void
dh_validator_default_init (DhValidatorIface * iface,
                           gpointer iface_data)
{
}

static GType
dh_validator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhValidatorIface), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_validator_default_init, (GClassFinalizeFunc) NULL, NULL, 0, 0, (GInstanceInitFunc) NULL, NULL };
	GType dh_validator_type_id;
	dh_validator_type_id = g_type_register_static (G_TYPE_INTERFACE, "DhValidator", &g_define_type_info, 0);
	g_type_interface_add_prerequisite (dh_validator_type_id, G_TYPE_OBJECT);
	return dh_validator_type_id;
}

GType
dh_validator_get_type (void)
{
	static volatile gsize dh_validator_type_id__once = 0;
	if (g_once_init_enter (&dh_validator_type_id__once)) {
		GType dh_validator_type_id;
		dh_validator_type_id = dh_validator_get_type_once ();
		g_once_init_leave (&dh_validator_type_id__once, dh_validator_type_id);
	}
	return dh_validator_type_id__once;
}

static inline gpointer
dh_int_validator_get_instance_private (DhIntValidator* self)
{
	return G_STRUCT_MEMBER_P (self, DhIntValidator_private_offset);
}

DhIntValidator*
dh_int_validator_construct_ignore_range (GType object_type,
                                         gboolean ir)
{
	DhIntValidator * self = NULL;
	self = (DhIntValidator*) g_object_new (object_type, NULL);
	self->priv->ignore = ir;
	return self;
}

DhIntValidator*
dh_int_validator_new_ignore_range (gboolean ir)
{
	return dh_int_validator_construct_ignore_range (TYPE_DH_INT_VALIDATOR, ir);
}

DhIntValidator*
dh_int_validator_construct (GType object_type,
                            gint64 min,
                            gint64 max)
{
	DhIntValidator * self = NULL;
	self = (DhIntValidator*) g_object_new (object_type, NULL);
	dh_validator_set_range ((DhValidator*) self, &min, &max);
	return self;
}

DhIntValidator*
dh_int_validator_new (gint64 min,
                      gint64 max)
{
	return dh_int_validator_construct (TYPE_DH_INT_VALIDATOR, min, max);
}

static gboolean
dh_int_validator_real_in_field (DhValidator* base,
                                gint64* val)
{
	DhIntValidator * self;
	gboolean _tmp0_ = FALSE;
	gboolean result;
	self = (DhIntValidator*) base;
	if (self->priv->ignore) {
		result = TRUE;
		return result;
	}
	if ((*val) >= self->priv->min) {
		_tmp0_ = (*val) <= self->priv->max;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}

static void
dh_int_validator_real_set_range (DhValidator* base,
                                 gint64* min_val,
                                 gint64* max_val)
{
	DhIntValidator * self;
	self = (DhIntValidator*) base;
	if ((*min_val) > (*max_val)) {
		self->priv->min = *max_val;
		self->priv->max = *min_val;
	} else {
		self->priv->min = *min_val;
		self->priv->max = *max_val;
	}
}

static void
dh_int_validator_class_init (DhIntValidatorClass * klass,
                             gpointer klass_data)
{
	dh_int_validator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DhIntValidator_private_offset);
	G_OBJECT_CLASS (klass)->finalize = dh_int_validator_finalize;
}

static void
dh_int_validator_dh_validator_interface_init (DhValidatorIface * iface,
                                              gpointer iface_data)
{
	dh_int_validator_dh_validator_parent_iface = g_type_interface_peek_parent (iface);
	iface->in_field = (gboolean (*) (DhValidator*, gconstpointer)) dh_int_validator_real_in_field;
	iface->set_range = (void (*) (DhValidator*, gconstpointer, gconstpointer)) dh_int_validator_real_set_range;
}

static void
dh_int_validator_instance_init (DhIntValidator * self,
                                gpointer klass)
{
	self->priv = dh_int_validator_get_instance_private (self);
	self->priv->ignore = FALSE;
}

static void
dh_int_validator_finalize (GObject * obj)
{
	DhIntValidator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DH_INT_VALIDATOR, DhIntValidator);
	G_OBJECT_CLASS (dh_int_validator_parent_class)->finalize (obj);
}

static GType
dh_int_validator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhIntValidatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_int_validator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DhIntValidator), 0, (GInstanceInitFunc) dh_int_validator_instance_init, NULL };
	static const GInterfaceInfo dh_validator_info = { (GInterfaceInitFunc) dh_int_validator_dh_validator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType dh_int_validator_type_id;
	dh_int_validator_type_id = g_type_register_static (G_TYPE_OBJECT, "DhIntValidator", &g_define_type_info, 0);
	g_type_add_interface_static (dh_int_validator_type_id, TYPE_DH_VALIDATOR, &dh_validator_info);
	DhIntValidator_private_offset = g_type_add_instance_private (dh_int_validator_type_id, sizeof (DhIntValidatorPrivate));
	return dh_int_validator_type_id;
}

GType
dh_int_validator_get_type (void)
{
	static volatile gsize dh_int_validator_type_id__once = 0;
	if (g_once_init_enter (&dh_int_validator_type_id__once)) {
		GType dh_int_validator_type_id;
		dh_int_validator_type_id = dh_int_validator_get_type_once ();
		g_once_init_leave (&dh_int_validator_type_id__once, dh_int_validator_type_id);
	}
	return dh_int_validator_type_id__once;
}

static inline gpointer
dh_uint_validator_get_instance_private (DhUIntValidator* self)
{
	return G_STRUCT_MEMBER_P (self, DhUIntValidator_private_offset);
}

DhUIntValidator*
dh_uint_validator_construct_ignore_range (GType object_type,
                                          gboolean ir)
{
	DhUIntValidator * self = NULL;
	self = (DhUIntValidator*) g_object_new (object_type, NULL);
	self->priv->ignore = ir;
	return self;
}

DhUIntValidator*
dh_uint_validator_new_ignore_range (gboolean ir)
{
	return dh_uint_validator_construct_ignore_range (TYPE_DH_UINT_VALIDATOR, ir);
}

DhUIntValidator*
dh_uint_validator_construct (GType object_type,
                             guint64 min,
                             guint64 max)
{
	DhUIntValidator * self = NULL;
	self = (DhUIntValidator*) g_object_new (object_type, NULL);
	dh_validator_set_range ((DhValidator*) self, &min, &max);
	return self;
}

DhUIntValidator*
dh_uint_validator_new (guint64 min,
                       guint64 max)
{
	return dh_uint_validator_construct (TYPE_DH_UINT_VALIDATOR, min, max);
}

static gboolean
dh_uint_validator_real_in_field (DhValidator* base,
                                 guint64* val)
{
	DhUIntValidator * self;
	gboolean _tmp0_ = FALSE;
	gboolean result;
	self = (DhUIntValidator*) base;
	if (self->priv->ignore) {
		result = TRUE;
		return result;
	}
	if ((*val) >= self->priv->min) {
		_tmp0_ = (*val) <= self->priv->max;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}

static void
dh_uint_validator_real_set_range (DhValidator* base,
                                  guint64* min_val,
                                  guint64* max_val)
{
	DhUIntValidator * self;
	self = (DhUIntValidator*) base;
	if ((*min_val) > (*max_val)) {
		self->priv->min = *max_val;
		self->priv->max = *min_val;
	} else {
		self->priv->min = *min_val;
		self->priv->max = *max_val;
	}
}

static void
dh_uint_validator_class_init (DhUIntValidatorClass * klass,
                              gpointer klass_data)
{
	dh_uint_validator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DhUIntValidator_private_offset);
	G_OBJECT_CLASS (klass)->finalize = dh_uint_validator_finalize;
}

static void
dh_uint_validator_dh_validator_interface_init (DhValidatorIface * iface,
                                               gpointer iface_data)
{
	dh_uint_validator_dh_validator_parent_iface = g_type_interface_peek_parent (iface);
	iface->in_field = (gboolean (*) (DhValidator*, gconstpointer)) dh_uint_validator_real_in_field;
	iface->set_range = (void (*) (DhValidator*, gconstpointer, gconstpointer)) dh_uint_validator_real_set_range;
}

static void
dh_uint_validator_instance_init (DhUIntValidator * self,
                                 gpointer klass)
{
	self->priv = dh_uint_validator_get_instance_private (self);
	self->priv->ignore = FALSE;
}

static void
dh_uint_validator_finalize (GObject * obj)
{
	DhUIntValidator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DH_UINT_VALIDATOR, DhUIntValidator);
	G_OBJECT_CLASS (dh_uint_validator_parent_class)->finalize (obj);
}

static GType
dh_uint_validator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhUIntValidatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_uint_validator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DhUIntValidator), 0, (GInstanceInitFunc) dh_uint_validator_instance_init, NULL };
	static const GInterfaceInfo dh_validator_info = { (GInterfaceInitFunc) dh_uint_validator_dh_validator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType dh_uint_validator_type_id;
	dh_uint_validator_type_id = g_type_register_static (G_TYPE_OBJECT, "DhUIntValidator", &g_define_type_info, 0);
	g_type_add_interface_static (dh_uint_validator_type_id, TYPE_DH_VALIDATOR, &dh_validator_info);
	DhUIntValidator_private_offset = g_type_add_instance_private (dh_uint_validator_type_id, sizeof (DhUIntValidatorPrivate));
	return dh_uint_validator_type_id;
}

GType
dh_uint_validator_get_type (void)
{
	static volatile gsize dh_uint_validator_type_id__once = 0;
	if (g_once_init_enter (&dh_uint_validator_type_id__once)) {
		GType dh_uint_validator_type_id;
		dh_uint_validator_type_id = dh_uint_validator_get_type_once ();
		g_once_init_leave (&dh_uint_validator_type_id__once, dh_uint_validator_type_id);
	}
	return dh_uint_validator_type_id__once;
}

static inline gpointer
dh_double_validator_get_instance_private (DhDoubleValidator* self)
{
	return G_STRUCT_MEMBER_P (self, DhDoubleValidator_private_offset);
}

DhDoubleValidator*
dh_double_validator_construct_ignore_range (GType object_type,
                                            gboolean ir)
{
	DhDoubleValidator * self = NULL;
	self = (DhDoubleValidator*) g_object_new (object_type, NULL);
	self->priv->ignore = ir;
	return self;
}

DhDoubleValidator*
dh_double_validator_new_ignore_range (gboolean ir)
{
	return dh_double_validator_construct_ignore_range (TYPE_DH_DOUBLE_VALIDATOR, ir);
}

DhDoubleValidator*
dh_double_validator_construct (GType object_type,
                               gdouble min,
                               gdouble max)
{
	DhDoubleValidator * self = NULL;
	self = (DhDoubleValidator*) g_object_new (object_type, NULL);
	dh_validator_set_range ((DhValidator*) self, &min, &max);
	return self;
}

DhDoubleValidator*
dh_double_validator_new (gdouble min,
                         gdouble max)
{
	return dh_double_validator_construct (TYPE_DH_DOUBLE_VALIDATOR, min, max);
}

static gboolean
dh_double_validator_real_in_field (DhValidator* base,
                                   gdouble* val)
{
	DhDoubleValidator * self;
	gboolean _tmp0_ = FALSE;
	gboolean result;
	self = (DhDoubleValidator*) base;
	if (self->priv->ignore) {
		result = TRUE;
		return result;
	}
	if ((*val) >= self->priv->min) {
		_tmp0_ = (*val) <= self->priv->max;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		result = TRUE;
		return result;
	} else {
		result = FALSE;
		return result;
	}
}

static void
dh_double_validator_real_set_range (DhValidator* base,
                                    gdouble* min_val,
                                    gdouble* max_val)
{
	DhDoubleValidator * self;
	self = (DhDoubleValidator*) base;
	if ((*min_val) > (*max_val)) {
		self->priv->min = *max_val;
		self->priv->max = *min_val;
	} else {
		self->priv->min = *min_val;
		self->priv->max = *max_val;
	}
}

static void
dh_double_validator_class_init (DhDoubleValidatorClass * klass,
                                gpointer klass_data)
{
	dh_double_validator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DhDoubleValidator_private_offset);
	G_OBJECT_CLASS (klass)->finalize = dh_double_validator_finalize;
}

static void
dh_double_validator_dh_validator_interface_init (DhValidatorIface * iface,
                                                 gpointer iface_data)
{
	dh_double_validator_dh_validator_parent_iface = g_type_interface_peek_parent (iface);
	iface->in_field = (gboolean (*) (DhValidator*, gconstpointer)) dh_double_validator_real_in_field;
	iface->set_range = (void (*) (DhValidator*, gconstpointer, gconstpointer)) dh_double_validator_real_set_range;
}

static void
dh_double_validator_instance_init (DhDoubleValidator * self,
                                   gpointer klass)
{
	self->priv = dh_double_validator_get_instance_private (self);
	self->priv->ignore = FALSE;
}

static void
dh_double_validator_finalize (GObject * obj)
{
	DhDoubleValidator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DH_DOUBLE_VALIDATOR, DhDoubleValidator);
	G_OBJECT_CLASS (dh_double_validator_parent_class)->finalize (obj);
}

static GType
dh_double_validator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhDoubleValidatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_double_validator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DhDoubleValidator), 0, (GInstanceInitFunc) dh_double_validator_instance_init, NULL };
	static const GInterfaceInfo dh_validator_info = { (GInterfaceInitFunc) dh_double_validator_dh_validator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType dh_double_validator_type_id;
	dh_double_validator_type_id = g_type_register_static (G_TYPE_OBJECT, "DhDoubleValidator", &g_define_type_info, 0);
	g_type_add_interface_static (dh_double_validator_type_id, TYPE_DH_VALIDATOR, &dh_validator_info);
	DhDoubleValidator_private_offset = g_type_add_instance_private (dh_double_validator_type_id, sizeof (DhDoubleValidatorPrivate));
	return dh_double_validator_type_id;
}

GType
dh_double_validator_get_type (void)
{
	static volatile gsize dh_double_validator_type_id__once = 0;
	if (g_once_init_enter (&dh_double_validator_type_id__once)) {
		GType dh_double_validator_type_id;
		dh_double_validator_type_id = dh_double_validator_get_type_once ();
		g_once_init_leave (&dh_double_validator_type_id__once, dh_double_validator_type_id);
	}
	return dh_double_validator_type_id__once;
}

static inline gpointer
dh_regex_validator_get_instance_private (DhRegexValidator* self)
{
	return G_STRUCT_MEMBER_P (self, DhRegexValidator_private_offset);
}

DhRegexValidator*
dh_regex_validator_construct (GType object_type,
                              GRegex* r)
{
	DhRegexValidator * self = NULL;
	g_return_val_if_fail (r != NULL, NULL);
	self = (DhRegexValidator*) g_object_new (object_type, NULL);
	dh_validator_set_range ((DhValidator*) self, r, NULL);
	return self;
}

DhRegexValidator*
dh_regex_validator_new (GRegex* r)
{
	return dh_regex_validator_construct (TYPE_DH_REGEX_VALIDATOR, r);
}

static gboolean
dh_regex_validator_real_in_field (DhValidator* base,
                                  const gchar* val)
{
	DhRegexValidator * self;
	GRegex* _tmp0_;
	gboolean result;
	self = (DhRegexValidator*) base;
	g_return_val_if_fail (val != NULL, FALSE);
	_tmp0_ = self->priv->reg;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	} else {
		GRegex* _tmp1_;
		_tmp1_ = self->priv->reg;
		result = g_regex_match (_tmp1_, val, 0, NULL);
		return result;
	}
}

static gpointer
_g_regex_ref0 (gpointer self)
{
	return self ? g_regex_ref (self) : NULL;
}

static void
dh_regex_validator_real_set_range (DhValidator* base,
                                   GRegex* min_val,
                                   GRegex* max_val)
{
	DhRegexValidator * self;
	self = (DhRegexValidator*) base;
	if (min_val != NULL) {
		GRegex* _tmp0_;
		_tmp0_ = _g_regex_ref0 (min_val);
		_g_regex_unref0 (self->priv->reg);
		self->priv->reg = _tmp0_;
	} else {
		GRegex* _tmp1_;
		_tmp1_ = _g_regex_ref0 (max_val);
		_g_regex_unref0 (self->priv->reg);
		self->priv->reg = _tmp1_;
	}
}

static void
dh_regex_validator_class_init (DhRegexValidatorClass * klass,
                               gpointer klass_data)
{
	dh_regex_validator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DhRegexValidator_private_offset);
	G_OBJECT_CLASS (klass)->finalize = dh_regex_validator_finalize;
}

static void
dh_regex_validator_dh_validator_interface_init (DhValidatorIface * iface,
                                                gpointer iface_data)
{
	dh_regex_validator_dh_validator_parent_iface = g_type_interface_peek_parent (iface);
	iface->in_field = (gboolean (*) (DhValidator*, gconstpointer)) dh_regex_validator_real_in_field;
	iface->set_range = (void (*) (DhValidator*, gconstpointer, gconstpointer)) dh_regex_validator_real_set_range;
}

static void
dh_regex_validator_instance_init (DhRegexValidator * self,
                                  gpointer klass)
{
	self->priv = dh_regex_validator_get_instance_private (self);
}

static void
dh_regex_validator_finalize (GObject * obj)
{
	DhRegexValidator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DH_REGEX_VALIDATOR, DhRegexValidator);
	_g_regex_unref0 (self->priv->reg);
	G_OBJECT_CLASS (dh_regex_validator_parent_class)->finalize (obj);
}

static GType
dh_regex_validator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhRegexValidatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_regex_validator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DhRegexValidator), 0, (GInstanceInitFunc) dh_regex_validator_instance_init, NULL };
	static const GInterfaceInfo dh_validator_info = { (GInterfaceInitFunc) dh_regex_validator_dh_validator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType dh_regex_validator_type_id;
	dh_regex_validator_type_id = g_type_register_static (G_TYPE_OBJECT, "DhRegexValidator", &g_define_type_info, 0);
	g_type_add_interface_static (dh_regex_validator_type_id, TYPE_DH_VALIDATOR, &dh_validator_info);
	DhRegexValidator_private_offset = g_type_add_instance_private (dh_regex_validator_type_id, sizeof (DhRegexValidatorPrivate));
	return dh_regex_validator_type_id;
}

GType
dh_regex_validator_get_type (void)
{
	static volatile gsize dh_regex_validator_type_id__once = 0;
	if (g_once_init_enter (&dh_regex_validator_type_id__once)) {
		GType dh_regex_validator_type_id;
		dh_regex_validator_type_id = dh_regex_validator_get_type_once ();
		g_once_init_leave (&dh_regex_validator_type_id__once, dh_regex_validator_type_id);
	}
	return dh_regex_validator_type_id__once;
}

static inline gpointer
dh_match_validator_get_instance_private (DhMatchValidator* self)
{
	return G_STRUCT_MEMBER_P (self, DhMatchValidator_private_offset);
}

DhMatchValidator*
dh_match_validator_construct_ignore_range (GType object_type,
                                           gboolean ir)
{
	DhMatchValidator * self = NULL;
	self = (DhMatchValidator*) g_object_new (object_type, NULL);
	self->priv->ignore = ir;
	return self;
}

DhMatchValidator*
dh_match_validator_new_ignore_range (gboolean ir)
{
	return dh_match_validator_construct_ignore_range (TYPE_DH_MATCH_VALIDATOR, ir);
}

DhMatchValidator*
dh_match_validator_construct (GType object_type,
                              const gchar* str)
{
	DhMatchValidator * self = NULL;
	g_return_val_if_fail (str != NULL, NULL);
	self = (DhMatchValidator*) g_object_new (object_type, NULL);
	dh_validator_set_range ((DhValidator*) self, str, "");
	return self;
}

DhMatchValidator*
dh_match_validator_new (const gchar* str)
{
	return dh_match_validator_construct (TYPE_DH_MATCH_VALIDATOR, str);
}

static gboolean
dh_match_validator_real_in_field (DhValidator* base,
                                  const gchar* val)
{
	DhMatchValidator * self;
	const gchar* _tmp0_;
	gboolean result;
	self = (DhMatchValidator*) base;
	g_return_val_if_fail (val != NULL, FALSE);
	if (self->priv->ignore) {
		result = TRUE;
		return result;
	}
	_tmp0_ = self->priv->match_str;
	if (_tmp0_ == NULL) {
		result = FALSE;
		return result;
	} else {
		const gchar* _tmp1_;
		_tmp1_ = self->priv->match_str;
		result = g_regex_match_simple (_tmp1_, val, 0, 0);
		return result;
	}
}

static void
dh_match_validator_real_set_range (DhValidator* base,
                                   const gchar* min_val,
                                   const gchar* max_val)
{
	DhMatchValidator * self;
	self = (DhMatchValidator*) base;
	g_return_if_fail (min_val != NULL);
	g_return_if_fail (max_val != NULL);
	if (min_val != NULL) {
		gchar* _tmp0_;
		_tmp0_ = g_strdup (min_val);
		_g_free0 (self->priv->match_str);
		self->priv->match_str = _tmp0_;
	} else {
		gchar* _tmp1_;
		_tmp1_ = g_strdup (max_val);
		_g_free0 (self->priv->match_str);
		self->priv->match_str = _tmp1_;
	}
}

static void
dh_match_validator_class_init (DhMatchValidatorClass * klass,
                               gpointer klass_data)
{
	dh_match_validator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DhMatchValidator_private_offset);
	G_OBJECT_CLASS (klass)->finalize = dh_match_validator_finalize;
}

static void
dh_match_validator_dh_validator_interface_init (DhValidatorIface * iface,
                                                gpointer iface_data)
{
	dh_match_validator_dh_validator_parent_iface = g_type_interface_peek_parent (iface);
	iface->in_field = (gboolean (*) (DhValidator*, gconstpointer)) dh_match_validator_real_in_field;
	iface->set_range = (void (*) (DhValidator*, gconstpointer, gconstpointer)) dh_match_validator_real_set_range;
}

static void
dh_match_validator_instance_init (DhMatchValidator * self,
                                  gpointer klass)
{
	self->priv = dh_match_validator_get_instance_private (self);
	self->priv->ignore = FALSE;
}

static void
dh_match_validator_finalize (GObject * obj)
{
	DhMatchValidator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DH_MATCH_VALIDATOR, DhMatchValidator);
	_g_free0 (self->priv->match_str);
	G_OBJECT_CLASS (dh_match_validator_parent_class)->finalize (obj);
}

static GType
dh_match_validator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhMatchValidatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_match_validator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DhMatchValidator), 0, (GInstanceInitFunc) dh_match_validator_instance_init, NULL };
	static const GInterfaceInfo dh_validator_info = { (GInterfaceInitFunc) dh_match_validator_dh_validator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType dh_match_validator_type_id;
	dh_match_validator_type_id = g_type_register_static (G_TYPE_OBJECT, "DhMatchValidator", &g_define_type_info, 0);
	g_type_add_interface_static (dh_match_validator_type_id, TYPE_DH_VALIDATOR, &dh_validator_info);
	DhMatchValidator_private_offset = g_type_add_instance_private (dh_match_validator_type_id, sizeof (DhMatchValidatorPrivate));
	return dh_match_validator_type_id;
}

GType
dh_match_validator_get_type (void)
{
	static volatile gsize dh_match_validator_type_id__once = 0;
	if (g_once_init_enter (&dh_match_validator_type_id__once)) {
		GType dh_match_validator_type_id;
		dh_match_validator_type_id = dh_match_validator_get_type_once ();
		g_once_init_leave (&dh_match_validator_type_id__once, dh_match_validator_type_id);
	}
	return dh_match_validator_type_id__once;
}

static inline gpointer
dh_int_array_validator_get_instance_private (DhIntArrayValidator* self)
{
	return G_STRUCT_MEMBER_P (self, DhIntArrayValidator_private_offset);
}

static void
_g_free0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (g_free (var), NULL));
}

static inline void
_g_list_free__g_free0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _g_free0_);
}

DhIntArrayValidator*
dh_int_array_validator_construct_ignore_range (GType object_type,
                                               gboolean ir)
{
	DhIntArrayValidator * self = NULL;
	self = (DhIntArrayValidator*) g_object_new (object_type, NULL);
	self->priv->ignore = ir;
	return self;
}

DhIntArrayValidator*
dh_int_array_validator_new_ignore_range (gboolean ir)
{
	return dh_int_array_validator_construct_ignore_range (TYPE_DH_INT_ARRAY_VALIDATOR, ir);
}

static gboolean
dh_int_array_validator_real_in_field (DhValidator* base,
                                      GList* val)
{
	DhIntArrayValidator * self;
	guint len = 0U;
	GList* _tmp0_;
	gboolean same_range = FALSE;
	gboolean result;
	self = (DhIntArrayValidator*) base;
	if (self->priv->ignore) {
		result = TRUE;
		return result;
	}
	_tmp0_ = self->priv->min;
	len = g_list_length (_tmp0_);
	same_range = FALSE;
	if (len == ((guint) 1)) {
		same_range = TRUE;
	}
	if (!self->priv->allow_repeated) {
		{
			gint i = 0;
			i = 0;
			{
				gboolean _tmp1_ = FALSE;
				_tmp1_ = TRUE;
				while (TRUE) {
					gint64 temp = 0LL;
					gconstpointer _tmp3_;
					if (!_tmp1_) {
						gint _tmp2_;
						_tmp2_ = i;
						i = _tmp2_ + 1;
					}
					_tmp1_ = FALSE;
					if (!(((guint) i) < g_list_length (val))) {
						break;
					}
					_tmp3_ = g_list_nth_data (val, (guint) i);
					temp = *((gint64*) _tmp3_);
					{
						gint j = 0;
						j = i + 1;
						{
							gboolean _tmp4_ = FALSE;
							_tmp4_ = TRUE;
							while (TRUE) {
								gint64 temp_1 = 0LL;
								gconstpointer _tmp6_;
								if (!_tmp4_) {
									gint _tmp5_;
									_tmp5_ = j;
									j = _tmp5_ + 1;
								}
								_tmp4_ = FALSE;
								if (!(((guint) j) < g_list_length (val))) {
									break;
								}
								_tmp6_ = g_list_nth_data (val, (guint) j);
								temp_1 = *((gint64*) _tmp6_);
								if (temp == temp_1) {
									result = FALSE;
									return result;
								}
							}
						}
					}
				}
			}
		}
	}
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp7_ = FALSE;
			_tmp7_ = TRUE;
			while (TRUE) {
				gint64 min_val = 0LL;
				gint64 max_val = 0LL;
				gboolean _tmp17_ = FALSE;
				gconstpointer _tmp18_;
				if (!_tmp7_) {
					gint _tmp8_;
					_tmp8_ = i;
					i = _tmp8_ + 1;
				}
				_tmp7_ = FALSE;
				if (!(((guint) i) < g_list_length (val))) {
					break;
				}
				if (same_range) {
					GList* _tmp9_;
					gconstpointer _tmp10_;
					GList* _tmp11_;
					gconstpointer _tmp12_;
					_tmp9_ = self->priv->min;
					_tmp10_ = g_list_nth_data (_tmp9_, (guint) 0);
					min_val = (gint64) (*((gint64*) _tmp10_));
					_tmp11_ = self->priv->max;
					_tmp12_ = g_list_nth_data (_tmp11_, (guint) 0);
					max_val = (gint64) (*((gint64*) _tmp12_));
				} else {
					GList* _tmp13_;
					gconstpointer _tmp14_;
					GList* _tmp15_;
					gconstpointer _tmp16_;
					_tmp13_ = self->priv->min;
					_tmp14_ = g_list_nth_data (_tmp13_, (guint) i);
					min_val = (gint64) (*((gint64*) _tmp14_));
					_tmp15_ = self->priv->max;
					_tmp16_ = g_list_nth_data (_tmp15_, (guint) i);
					max_val = (gint64) (*((gint64*) _tmp16_));
				}
				_tmp18_ = g_list_nth_data (val, (guint) i);
				if ((*((gint64*) _tmp18_)) < min_val) {
					_tmp17_ = TRUE;
				} else {
					gconstpointer _tmp19_;
					_tmp19_ = g_list_nth_data (val, (guint) i);
					_tmp17_ = (*((gint64*) _tmp19_)) > max_val;
				}
				if (_tmp17_) {
					result = FALSE;
					return result;
				}
			}
		}
	}
	result = TRUE;
	return result;
}

static void
dh_int_array_validator_real_set_range (DhValidator* base,
                                       GList* min_val,
                                       GList* max_val)
{
	DhIntArrayValidator * self;
	GList* _tmp0_;
	GList* _tmp1_;
	self = (DhIntArrayValidator*) base;
	_tmp0_ = g_list_copy (min_val);
	(self->priv->min == NULL) ? NULL : (self->priv->min = (_g_list_free__g_free0_ (self->priv->min), NULL));
	self->priv->min = (GList*) _tmp0_;
	_tmp1_ = g_list_copy (max_val);
	(self->priv->max == NULL) ? NULL : (self->priv->max = (_g_list_free__g_free0_ (self->priv->max), NULL));
	self->priv->max = (GList*) _tmp1_;
}

static gint64*
_int64_dup (gint64* self)
{
	gint64* dup;
	dup = g_new0 (gint64, 1);
	memcpy (dup, self, sizeof (gint64));
	return dup;
}

static gpointer
__int64_dup0 (gpointer self)
{
	return self ? _int64_dup (self) : NULL;
}

void
dh_int_array_validator_add_range (DhIntArrayValidator* self,
                                  gint64 min_val,
                                  gint64 max_val)
{
	gint64* _tmp0_;
	gint64* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = __int64_dup0 (&min_val);
	self->priv->min = g_list_append (self->priv->min, _tmp0_);
	_tmp1_ = __int64_dup0 (&max_val);
	self->priv->max = g_list_append (self->priv->max, _tmp1_);
}

void
dh_int_array_validator_set_split_str (DhIntArrayValidator* self,
                                      const gchar* sp_str)
{
	gchar* _tmp0_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (sp_str != NULL);
	_tmp0_ = g_strdup (sp_str);
	_g_free0 (self->split_str);
	self->split_str = _tmp0_;
}

void
dh_int_array_validator_set_allow_repeated (DhIntArrayValidator* self,
                                           gboolean ar)
{
	g_return_if_fail (self != NULL);
	self->priv->allow_repeated = ar;
}

DhIntArrayValidator*
dh_int_array_validator_construct (GType object_type)
{
	DhIntArrayValidator * self = NULL;
	self = (DhIntArrayValidator*) g_object_new (object_type, NULL);
	return self;
}

DhIntArrayValidator*
dh_int_array_validator_new (void)
{
	return dh_int_array_validator_construct (TYPE_DH_INT_ARRAY_VALIDATOR);
}

static void
dh_int_array_validator_class_init (DhIntArrayValidatorClass * klass,
                                   gpointer klass_data)
{
	dh_int_array_validator_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DhIntArrayValidator_private_offset);
	G_OBJECT_CLASS (klass)->finalize = dh_int_array_validator_finalize;
}

static void
dh_int_array_validator_dh_validator_interface_init (DhValidatorIface * iface,
                                                    gpointer iface_data)
{
	dh_int_array_validator_dh_validator_parent_iface = g_type_interface_peek_parent (iface);
	iface->in_field = (gboolean (*) (DhValidator*, gconstpointer)) dh_int_array_validator_real_in_field;
	iface->set_range = (void (*) (DhValidator*, gconstpointer, gconstpointer)) dh_int_array_validator_real_set_range;
}

static void
dh_int_array_validator_instance_init (DhIntArrayValidator * self,
                                      gpointer klass)
{
	self->priv = dh_int_array_validator_get_instance_private (self);
	self->priv->min = NULL;
	self->priv->max = NULL;
	self->priv->ignore = FALSE;
}

static void
dh_int_array_validator_finalize (GObject * obj)
{
	DhIntArrayValidator * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DH_INT_ARRAY_VALIDATOR, DhIntArrayValidator);
	(self->priv->min == NULL) ? NULL : (self->priv->min = (_g_list_free__g_free0_ (self->priv->min), NULL));
	(self->priv->max == NULL) ? NULL : (self->priv->max = (_g_list_free__g_free0_ (self->priv->max), NULL));
	_g_free0 (self->split_str);
	G_OBJECT_CLASS (dh_int_array_validator_parent_class)->finalize (obj);
}

static GType
dh_int_array_validator_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhIntArrayValidatorClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_int_array_validator_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DhIntArrayValidator), 0, (GInstanceInitFunc) dh_int_array_validator_instance_init, NULL };
	static const GInterfaceInfo dh_validator_info = { (GInterfaceInitFunc) dh_int_array_validator_dh_validator_interface_init, (GInterfaceFinalizeFunc) NULL, NULL};
	GType dh_int_array_validator_type_id;
	dh_int_array_validator_type_id = g_type_register_static (G_TYPE_OBJECT, "DhIntArrayValidator", &g_define_type_info, 0);
	g_type_add_interface_static (dh_int_array_validator_type_id, TYPE_DH_VALIDATOR, &dh_validator_info);
	DhIntArrayValidator_private_offset = g_type_add_instance_private (dh_int_array_validator_type_id, sizeof (DhIntArrayValidatorPrivate));
	return dh_int_array_validator_type_id;
}

GType
dh_int_array_validator_get_type (void)
{
	static volatile gsize dh_int_array_validator_type_id__once = 0;
	if (g_once_init_enter (&dh_int_array_validator_type_id__once)) {
		GType dh_int_array_validator_type_id;
		dh_int_array_validator_type_id = dh_int_array_validator_get_type_once ();
		g_once_init_leave (&dh_int_array_validator_type_id__once, dh_int_array_validator_type_id);
	}
	return dh_int_array_validator_type_id__once;
}

static inline gpointer
dh_arg_info_get_instance_private (DhArgInfo* self)
{
	return G_STRUCT_MEMBER_P (self, DhArgInfo_private_offset);
}

void
dh_arg_info_add_arg (DhArgInfo* self,
                     gchar new_arg,
                     const gchar* new_arg_fullname,
                     const gchar* new_description)
{
	gchar* _tmp0_;
	gchar* _tmp1_;
	gboolean _tmp2_ = FALSE;
	GList* _tmp3_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (new_arg_fullname != NULL);
	g_return_if_fail (new_description != NULL);
	self->arg = g_list_append (self->arg, (gpointer) ((gintptr) new_arg));
	_tmp0_ = g_strdup (new_arg_fullname);
	self->arg_fullname = g_list_append (self->arg_fullname, _tmp0_);
	_tmp1_ = g_strdup (new_description);
	self->description = g_list_append (self->description, _tmp1_);
	_tmp3_ = self->arg;
	if (g_list_length (_tmp3_) == ((guint) 1)) {
		_tmp2_ = ((gint) self->priv->default_arg) == 0;
	} else {
		_tmp2_ = FALSE;
	}
	if (_tmp2_) {
		GList* _tmp4_;
		gconstpointer _tmp5_;
		_tmp4_ = self->arg;
		_tmp5_ = g_list_nth_data (_tmp4_, (guint) 0);
		self->priv->default_arg = (gchar) ((gintptr) _tmp5_);
	}
}

gchar*
dh_arg_info_help_message (DhArgInfo* self,
                          const gchar* gettext_package)
{
	gchar* str = NULL;
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (gettext_package != NULL, NULL);
	_tmp0_ = g_strdup (g_dgettext ("dhutil", "The arguments are:\n"));
	str = _tmp0_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				GList* _tmp3_;
				GList* _tmp4_;
				gconstpointer _tmp5_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = self->arg;
				if (!(((guint) i) < g_list_length (_tmp3_))) {
					break;
				}
				_tmp4_ = self->arg;
				_tmp5_ = g_list_nth_data (_tmp4_, (guint) 0);
				if (((gint) ((gchar) ((gintptr) _tmp5_))) != 0) {
					gchar* printf_str = NULL;
					gchar* _tmp6_;
					const gchar* _tmp7_;
					GList* _tmp8_;
					gconstpointer _tmp9_;
					GList* _tmp10_;
					gconstpointer _tmp11_;
					GList* _tmp12_;
					gconstpointer _tmp13_;
					gchar* _tmp14_;
					const gchar* _tmp15_;
					const gchar* _tmp16_;
					gchar* _tmp17_;
					_tmp6_ = g_strdup ("\"%c\", \t\"%s\", \t\"%s\"\n");
					printf_str = _tmp6_;
					_tmp7_ = printf_str;
					_tmp8_ = self->arg;
					_tmp9_ = g_list_nth_data (_tmp8_, (guint) i);
					_tmp10_ = self->arg_fullname;
					_tmp11_ = g_list_nth_data (_tmp10_, (guint) i);
					_tmp12_ = self->description;
					_tmp13_ = g_list_nth_data (_tmp12_, (guint) i);
					_tmp14_ = g_strdup_printf (_tmp7_, (gchar) ((gintptr) _tmp9_), (const gchar*) _tmp11_, g_dgettext (gettext_package, (const gchar*) _tmp13_));
					_g_free0 (printf_str);
					printf_str = _tmp14_;
					_tmp15_ = str;
					_tmp16_ = printf_str;
					_tmp17_ = g_strconcat (_tmp15_, _tmp16_, NULL);
					_g_free0 (str);
					str = _tmp17_;
					_g_free0 (printf_str);
				} else {
					gchar* printf_str = NULL;
					gchar* _tmp18_;
					const gchar* _tmp19_;
					GList* _tmp20_;
					gconstpointer _tmp21_;
					GList* _tmp22_;
					gconstpointer _tmp23_;
					gchar* _tmp24_;
					const gchar* _tmp25_;
					const gchar* _tmp26_;
					gchar* _tmp27_;
					_tmp18_ = g_strdup ("\"\", \t\"%s\", \t\"%s\"\n");
					printf_str = _tmp18_;
					_tmp19_ = printf_str;
					_tmp20_ = self->arg_fullname;
					_tmp21_ = g_list_nth_data (_tmp20_, (guint) i);
					_tmp22_ = self->description;
					_tmp23_ = g_list_nth_data (_tmp22_, (guint) i);
					_tmp24_ = g_strdup_printf (_tmp19_, (const gchar*) _tmp21_, g_dgettext (gettext_package, (const gchar*) _tmp23_));
					_g_free0 (printf_str);
					printf_str = _tmp24_;
					_tmp25_ = str;
					_tmp26_ = printf_str;
					_tmp27_ = g_strconcat (_tmp25_, _tmp26_, NULL);
					_g_free0 (str);
					str = _tmp27_;
					_g_free0 (printf_str);
				}
			}
		}
	}
	result = str;
	return result;
}

gchar
dh_arg_info_match_char (DhArgInfo* self,
                        const gchar* str)
{
	gchar* pstr = NULL;
	gchar* _tmp0_;
	const gchar* _tmp24_;
	gchar result;
	g_return_val_if_fail (self != NULL, '\0');
	g_return_val_if_fail (str != NULL, '\0');
	_tmp0_ = g_ascii_strdown (str, (gssize) -1);
	pstr = _tmp0_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				GList* _tmp3_;
				gchar* match_str = NULL;
				gchar* _tmp4_;
				const gchar* _tmp5_;
				GList* _tmp6_;
				gconstpointer _tmp7_;
				gchar* _tmp8_;
				gboolean _tmp9_ = FALSE;
				const gchar* _tmp10_;
				const gchar* _tmp11_;
				gchar* _tmp15_;
				const gchar* _tmp16_;
				GList* _tmp17_;
				gconstpointer _tmp18_;
				gchar* _tmp19_;
				const gchar* _tmp20_;
				const gchar* _tmp21_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = self->arg;
				if (!(((guint) i) < g_list_length (_tmp3_))) {
					break;
				}
				_tmp4_ = g_strdup ("^%c$");
				match_str = _tmp4_;
				_tmp5_ = match_str;
				_tmp6_ = self->arg;
				_tmp7_ = g_list_nth_data (_tmp6_, (guint) i);
				_tmp8_ = g_strdup_printf (_tmp5_, (gchar) ((gintptr) _tmp7_));
				_g_free0 (match_str);
				match_str = _tmp8_;
				_tmp10_ = match_str;
				_tmp11_ = pstr;
				if (g_regex_match_simple (_tmp10_, _tmp11_, 0, 0)) {
					const gchar* _tmp12_;
					_tmp12_ = match_str;
					_tmp9_ = g_strcmp0 (_tmp12_, "^$") != 0;
				} else {
					_tmp9_ = FALSE;
				}
				if (_tmp9_) {
					GList* _tmp13_;
					gconstpointer _tmp14_;
					_tmp13_ = self->arg;
					_tmp14_ = g_list_nth_data (_tmp13_, (guint) i);
					result = (gchar) ((gintptr) _tmp14_);
					_g_free0 (match_str);
					_g_free0 (pstr);
					return result;
				}
				_tmp15_ = g_strdup ("^%s$");
				_g_free0 (match_str);
				match_str = _tmp15_;
				_tmp16_ = match_str;
				_tmp17_ = self->arg_fullname;
				_tmp18_ = g_list_nth_data (_tmp17_, (guint) i);
				_tmp19_ = g_strdup_printf (_tmp16_, (const gchar*) _tmp18_);
				_g_free0 (match_str);
				match_str = _tmp19_;
				_tmp20_ = match_str;
				_tmp21_ = pstr;
				if (g_regex_match_simple (_tmp20_, _tmp21_, 0, 0)) {
					GList* _tmp22_;
					gconstpointer _tmp23_;
					_tmp22_ = self->arg;
					_tmp23_ = g_list_nth_data (_tmp22_, (guint) i);
					result = (gchar) ((gintptr) _tmp23_);
					_g_free0 (match_str);
					_g_free0 (pstr);
					return result;
				}
				_g_free0 (match_str);
			}
		}
	}
	_tmp24_ = pstr;
	if (g_strcmp0 (_tmp24_, "") == 0) {
		result = self->priv->default_arg;
		_g_free0 (pstr);
		return result;
	}
	result = (gchar) 0;
	_g_free0 (pstr);
	return result;
}

gchar*
dh_arg_info_match_string (DhArgInfo* self,
                          const gchar* str)
{
	gchar* pstr = NULL;
	gchar* _tmp0_;
	const gchar* _tmp28_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = g_strdup (str);
	pstr = _tmp0_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp1_ = FALSE;
			_tmp1_ = TRUE;
			while (TRUE) {
				GList* _tmp3_;
				gchar* match_str = NULL;
				GList* _tmp4_;
				gconstpointer _tmp5_;
				gchar* _tmp18_;
				const gchar* _tmp19_;
				GList* _tmp20_;
				gconstpointer _tmp21_;
				gchar* _tmp22_;
				const gchar* _tmp23_;
				const gchar* _tmp24_;
				if (!_tmp1_) {
					gint _tmp2_;
					_tmp2_ = i;
					i = _tmp2_ + 1;
				}
				_tmp1_ = FALSE;
				_tmp3_ = self->arg;
				if (!(((guint) i) < g_list_length (_tmp3_))) {
					break;
				}
				match_str = NULL;
				_tmp4_ = self->arg;
				_tmp5_ = g_list_nth_data (_tmp4_, (guint) i);
				if (((gint) ((gchar) ((gintptr) _tmp5_))) != 0) {
					gchar* _tmp6_;
					const gchar* _tmp7_;
					GList* _tmp8_;
					gconstpointer _tmp9_;
					gchar* _tmp10_;
					gboolean _tmp11_ = FALSE;
					const gchar* _tmp12_;
					const gchar* _tmp13_;
					_tmp6_ = g_strdup ("^%c$");
					_g_free0 (match_str);
					match_str = _tmp6_;
					_tmp7_ = match_str;
					_tmp8_ = self->arg;
					_tmp9_ = g_list_nth_data (_tmp8_, (guint) i);
					_tmp10_ = g_strdup_printf (_tmp7_, (gchar) ((gintptr) _tmp9_));
					_g_free0 (match_str);
					match_str = _tmp10_;
					_tmp12_ = match_str;
					_tmp13_ = pstr;
					if (g_regex_match_simple (_tmp12_, _tmp13_, 0, 0)) {
						const gchar* _tmp14_;
						_tmp14_ = match_str;
						_tmp11_ = g_strcmp0 (_tmp14_, "^$") != 0;
					} else {
						_tmp11_ = FALSE;
					}
					if (_tmp11_) {
						GList* _tmp15_;
						gconstpointer _tmp16_;
						gchar* _tmp17_;
						_tmp15_ = self->arg_fullname;
						_tmp16_ = g_list_nth_data (_tmp15_, (guint) i);
						_tmp17_ = g_strdup ((const gchar*) _tmp16_);
						result = _tmp17_;
						_g_free0 (match_str);
						_g_free0 (pstr);
						return result;
					}
				}
				_tmp18_ = g_strdup ("^%s$");
				_g_free0 (match_str);
				match_str = _tmp18_;
				_tmp19_ = match_str;
				_tmp20_ = self->arg_fullname;
				_tmp21_ = g_list_nth_data (_tmp20_, (guint) i);
				_tmp22_ = g_strdup_printf (_tmp19_, (const gchar*) _tmp21_);
				_g_free0 (match_str);
				match_str = _tmp22_;
				_tmp23_ = match_str;
				_tmp24_ = pstr;
				if (g_regex_match_simple (_tmp23_, _tmp24_, 0, 0)) {
					GList* _tmp25_;
					gconstpointer _tmp26_;
					gchar* _tmp27_;
					_tmp25_ = self->arg_fullname;
					_tmp26_ = g_list_nth_data (_tmp25_, (guint) i);
					_tmp27_ = g_strdup ((const gchar*) _tmp26_);
					result = _tmp27_;
					_g_free0 (match_str);
					_g_free0 (pstr);
					return result;
				}
				_g_free0 (match_str);
			}
		}
	}
	_tmp28_ = pstr;
	if (g_strcmp0 (_tmp28_, "") == 0) {
		GList* _tmp29_;
		gconstpointer _tmp30_;
		gchar* _tmp31_;
		_tmp29_ = self->arg_fullname;
		_tmp30_ = g_list_nth_data (_tmp29_, (guint) 0);
		_tmp31_ = g_strdup ((const gchar*) _tmp30_);
		result = _tmp31_;
		_g_free0 (pstr);
		return result;
	}
	result = NULL;
	_g_free0 (pstr);
	return result;
}

void
dh_arg_info_change_default_arg (DhArgInfo* self,
                                gchar arg)
{
	gint default_arg_pos = 0;
	gchar old_arg = '\0';
	GList* _tmp5_;
	gconstpointer _tmp6_;
	GList* _tmp7_;
	GList* _tmp8_;
	GList* _tmp9_;
	GList* _tmp10_;
	gchar* old_str = NULL;
	GList* _tmp11_;
	gconstpointer _tmp12_;
	gchar* _tmp13_;
	GList* _tmp14_;
	GList* _tmp15_;
	GList* _tmp16_;
	gconstpointer _tmp17_;
	gchar* _tmp18_;
	GList* _tmp19_;
	GList* _tmp20_;
	gchar* _tmp21_;
	gchar* old_description = NULL;
	GList* _tmp22_;
	gconstpointer _tmp23_;
	gchar* _tmp24_;
	GList* _tmp25_;
	GList* _tmp26_;
	GList* _tmp27_;
	gconstpointer _tmp28_;
	gchar* _tmp29_;
	GList* _tmp30_;
	GList* _tmp31_;
	gchar* _tmp32_;
	g_return_if_fail (self != NULL);
	self->priv->default_arg = arg;
	default_arg_pos = -1;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp0_ = FALSE;
			_tmp0_ = TRUE;
			while (TRUE) {
				GList* _tmp2_;
				GList* _tmp3_;
				gconstpointer _tmp4_;
				if (!_tmp0_) {
					gint _tmp1_;
					_tmp1_ = i;
					i = _tmp1_ + 1;
				}
				_tmp0_ = FALSE;
				_tmp2_ = self->arg;
				if (!(((guint) i) < g_list_length (_tmp2_))) {
					break;
				}
				_tmp3_ = self->arg;
				_tmp4_ = g_list_nth_data (_tmp3_, (guint) i);
				if (((gchar) ((gintptr) _tmp4_)) == arg) {
					default_arg_pos = i;
					break;
				}
			}
		}
	}
	_tmp5_ = self->arg;
	_tmp6_ = g_list_nth_data (_tmp5_, (guint) 0);
	old_arg = (gchar) ((gintptr) _tmp6_);
	_tmp7_ = self->arg;
	_tmp8_ = g_list_nth (_tmp7_, (guint) 0);
	_tmp8_->data = (gpointer) ((gintptr) arg);
	_tmp9_ = self->arg;
	_tmp10_ = g_list_nth (_tmp9_, (guint) default_arg_pos);
	_tmp10_->data = (gpointer) ((gintptr) old_arg);
	_tmp11_ = self->arg_fullname;
	_tmp12_ = g_list_nth_data (_tmp11_, (guint) 0);
	_tmp13_ = g_strdup ((const gchar*) _tmp12_);
	old_str = _tmp13_;
	_tmp14_ = self->arg_fullname;
	_tmp15_ = g_list_nth (_tmp14_, (guint) 0);
	_tmp16_ = self->arg_fullname;
	_tmp17_ = g_list_nth_data (_tmp16_, (guint) default_arg_pos);
	_tmp18_ = g_strdup ((const gchar*) _tmp17_);
	_g_free0 (_tmp15_->data);
	_tmp15_->data = _tmp18_;
	_tmp19_ = self->arg_fullname;
	_tmp20_ = g_list_nth (_tmp19_, (guint) default_arg_pos);
	_tmp21_ = g_strdup (old_str);
	_g_free0 (_tmp20_->data);
	_tmp20_->data = _tmp21_;
	_tmp22_ = self->description;
	_tmp23_ = g_list_nth_data (_tmp22_, (guint) 0);
	_tmp24_ = g_strdup ((const gchar*) _tmp23_);
	old_description = _tmp24_;
	_tmp25_ = self->description;
	_tmp26_ = g_list_nth (_tmp25_, (guint) 0);
	_tmp27_ = self->description;
	_tmp28_ = g_list_nth_data (_tmp27_, (guint) default_arg_pos);
	_tmp29_ = g_strdup ((const gchar*) _tmp28_);
	_g_free0 (_tmp26_->data);
	_tmp26_->data = _tmp29_;
	_tmp30_ = self->description;
	_tmp31_ = g_list_nth (_tmp30_, (guint) default_arg_pos);
	_tmp32_ = g_strdup (old_description);
	_g_free0 (_tmp31_->data);
	_tmp31_->data = _tmp32_;
	_g_free0 (old_description);
	_g_free0 (old_str);
}

DhArgInfo*
dh_arg_info_construct (GType object_type)
{
	DhArgInfo * self = NULL;
	self = (DhArgInfo*) g_object_new (object_type, NULL);
	return self;
}

DhArgInfo*
dh_arg_info_new (void)
{
	return dh_arg_info_construct (TYPE_DH_ARG_INFO);
}

static void
dh_arg_info_class_init (DhArgInfoClass * klass,
                        gpointer klass_data)
{
	dh_arg_info_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DhArgInfo_private_offset);
	G_OBJECT_CLASS (klass)->finalize = dh_arg_info_finalize;
}

static void
dh_arg_info_instance_init (DhArgInfo * self,
                           gpointer klass)
{
	self->priv = dh_arg_info_get_instance_private (self);
	self->priv->default_arg = (gchar) 0;
}

static void
dh_arg_info_finalize (GObject * obj)
{
	DhArgInfo * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DH_ARG_INFO, DhArgInfo);
	(self->arg == NULL) ? NULL : (self->arg = (g_list_free (self->arg), NULL));
	(self->arg_fullname == NULL) ? NULL : (self->arg_fullname = (_g_list_free__g_free0_ (self->arg_fullname), NULL));
	(self->description == NULL) ? NULL : (self->description = (_g_list_free__g_free0_ (self->description), NULL));
	G_OBJECT_CLASS (dh_arg_info_parent_class)->finalize (obj);
}

static GType
dh_arg_info_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhArgInfoClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_arg_info_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DhArgInfo), 0, (GInstanceInitFunc) dh_arg_info_instance_init, NULL };
	GType dh_arg_info_type_id;
	dh_arg_info_type_id = g_type_register_static (G_TYPE_OBJECT, "DhArgInfo", &g_define_type_info, 0);
	DhArgInfo_private_offset = g_type_add_instance_private (dh_arg_info_type_id, sizeof (DhArgInfoPrivate));
	return dh_arg_info_type_id;
}

GType
dh_arg_info_get_type (void)
{
	static volatile gsize dh_arg_info_type_id__once = 0;
	if (g_once_init_enter (&dh_arg_info_type_id__once)) {
		GType dh_arg_info_type_id;
		dh_arg_info_type_id = dh_arg_info_get_type_once ();
		g_once_init_leave (&dh_arg_info_type_id__once, dh_arg_info_type_id);
	}
	return dh_arg_info_type_id__once;
}

static inline gpointer
dh_out_get_instance_private (DhOut* self)
{
	return G_STRUCT_MEMBER_P (self, DhOut_private_offset);
}

static gchar**
_dh_out_dhutil_completion_rl_completion_func_t (const gchar* str,
                                                gint a,
                                                gint b)
{
	gchar** result;
	result = dh_out_dhutil_completion (str, a, b, NULL);
	return result;
}

static void
dh_out_init_readline (DhOut* self)
{
	g_return_if_fail (self != NULL);
	rl_readline_name = "dhutil";
	rl_attempted_completion_function = _dh_out_dhutil_completion_rl_completion_func_t;
}

static gchar*
dh_out_get_opt (DhOut* self,
                DhArgInfo* arg)
{
	gchar* str = NULL;
	gchar* _tmp0_;
	gchar* arg_str = NULL;
	gchar* _tmp1_;
	const gchar* _tmp15_;
	gchar* _tmp16_;
	const gchar* _tmp17_;
	const gchar* _tmp18_;
	gchar* _tmp19_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (arg != NULL, NULL);
	_tmp0_ = g_strdup ("[%s]");
	str = _tmp0_;
	_tmp1_ = g_strdup ("");
	arg_str = _tmp1_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				GList* _tmp4_;
				gchar* single_arg = NULL;
				GList* _tmp5_;
				gconstpointer _tmp6_;
				gchar* _tmp7_;
				const gchar* _tmp10_;
				const gchar* _tmp11_;
				gchar* _tmp12_;
				const gchar* _tmp13_;
				gchar* _tmp14_;
				if (!_tmp2_) {
					gint _tmp3_;
					_tmp3_ = i;
					i = _tmp3_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp4_ = arg->arg;
				if (!(((guint) i) < g_list_length (_tmp4_))) {
					break;
				}
				_tmp5_ = arg->arg;
				_tmp6_ = g_list_nth_data (_tmp5_, (guint) i);
				_tmp7_ = g_strnfill ((gsize) 1, (gchar) ((gintptr) _tmp6_));
				single_arg = _tmp7_;
				if (i == 0) {
					const gchar* _tmp8_;
					gchar* _tmp9_;
					_tmp8_ = single_arg;
					_tmp9_ = g_ascii_strup (_tmp8_, (gssize) 1);
					_g_free0 (single_arg);
					single_arg = _tmp9_;
				}
				_tmp10_ = arg_str;
				_tmp11_ = single_arg;
				_tmp12_ = g_strconcat (_tmp10_, _tmp11_, NULL);
				_g_free0 (arg_str);
				arg_str = _tmp12_;
				_tmp13_ = arg_str;
				_tmp14_ = g_strconcat (_tmp13_, "/", NULL);
				_g_free0 (arg_str);
				arg_str = _tmp14_;
				_g_free0 (single_arg);
			}
		}
	}
	_tmp15_ = arg_str;
	_tmp16_ = g_strconcat (_tmp15_, "?", NULL);
	_g_free0 (arg_str);
	arg_str = _tmp16_;
	_tmp17_ = str;
	_tmp18_ = arg_str;
	_tmp19_ = g_strdup_printf (_tmp17_, _tmp18_);
	_g_free0 (str);
	str = _tmp19_;
	result = str;
	_g_free0 (arg_str);
	return result;
}

void
dh_out_set_show_opt (DhOut* self,
                     gboolean option)
{
	g_return_if_fail (self != NULL);
	self->priv->show_opt = option;
}

void
dh_out_no_output_string_while_no_validator (DhOut* self)
{
	g_return_if_fail (self != NULL);
	self->priv->output_str_while_nov = FALSE;
}

static gchar*
_dh_out_dhutil_compeuntry_func_static_rl_compentry_func_t (const gchar* str,
                                                           gint a)
{
	gchar* result;
	result = dh_out_dhutil_compeuntry_func_static (str, a);
	return result;
}

static gchar**
_vala_array_dup1 (gchar** self,
                  gssize length)
{
	if (length >= 0) {
		gchar** result;
		gssize i;
		result = g_new0 (gchar*, length + 1);
		for (i = 0; i < length; i++) {
			gchar* _tmp0_;
			_tmp0_ = g_strdup (self[i]);
			result[i] = _tmp0_;
		}
		return result;
	}
	return NULL;
}

static gchar**
dh_out_dhutil_completion (const gchar* str,
                          gint a,
                          gint b,
                          gint* result_length1)
{
	gchar** matches = NULL;
	gint matches_length1;
	gint _matches_size_;
	gchar** _tmp3_;
	gint _tmp3__length1;
	gchar** result;
	g_return_val_if_fail (str != NULL, NULL);
	matches = NULL;
	matches_length1 = 0;
	_matches_size_ = matches_length1;
	if (a == 0) {
		gchar** _tmp0_;
		gchar** _tmp1_;
		gchar** _tmp2_;
		gint _tmp2__length1;
		_tmp1_ = _tmp0_ = rl_completion_matches (str, _dh_out_dhutil_compeuntry_func_static_rl_compentry_func_t);
		_tmp2_ = (_tmp1_ != NULL) ? _vala_array_dup1 (_tmp1_, _vala_array_length (_tmp0_)) : _tmp1_;
		_tmp2__length1 = _vala_array_length (_tmp0_);
		matches = (_vala_array_free (matches, matches_length1, (GDestroyNotify) g_free), NULL);
		matches = _tmp2_;
		matches_length1 = _tmp2__length1;
		_matches_size_ = matches_length1;
	}
	_tmp3_ = matches;
	_tmp3__length1 = matches_length1;
	if (result_length1) {
		*result_length1 = _tmp3__length1;
	}
	result = _tmp3_;
	return result;
}

void
dh_out_output_match_string_than_arg (DhOut* self)
{
	g_return_if_fail (self != NULL);
	self->priv->match_string = TRUE;
}

static gchar*
dh_out_dhutil_compeuntry_func (const gchar* str,
                               gint state)
{
	guint list_index = 0U;
	gchar* name = NULL;
	DhArgInfo* _tmp0_;
	gchar* result;
	g_return_val_if_fail (str != NULL, NULL);
	list_index = (guint) state;
	_tmp0_ = dh_out_info;
	if (_tmp0_ != NULL) {
		DhArgInfo* _tmp8_;
		GList* _tmp9_;
		gint _tmp10_;
		gint _tmp11_;
		while (TRUE) {
			DhArgInfo* _tmp1_;
			GList* _tmp2_;
			gconstpointer _tmp3_;
			gchar* _tmp4_;
			const gchar* _tmp5_;
			guint _tmp6_;
			const gchar* _tmp7_;
			_tmp1_ = dh_out_info;
			_tmp2_ = _tmp1_->arg_fullname;
			_tmp3_ = g_list_nth_data (_tmp2_, list_index);
			_tmp4_ = g_strdup ((const gchar*) _tmp3_);
			_g_free0 (name);
			name = _tmp4_;
			_tmp5_ = name;
			if (!(_tmp5_ != NULL)) {
				break;
			}
			_tmp6_ = list_index;
			list_index = _tmp6_ + 1;
			_tmp7_ = name;
			if (g_str_has_prefix (_tmp7_, str)) {
				result = name;
				return result;
			}
		}
		_tmp8_ = dh_out_info;
		_tmp9_ = _tmp8_->arg;
		list_index -= g_list_length (_tmp9_);
		_tmp10_ = strlen (str);
		_tmp11_ = _tmp10_;
		if (_tmp11_ == 0) {
			gchar* ret = NULL;
			gchar return_char = '\0';
			while (TRUE) {
				DhArgInfo* _tmp12_;
				GList* _tmp13_;
				gconstpointer _tmp14_;
				guint _tmp15_;
				gchar* _tmp16_;
				_tmp12_ = dh_out_info;
				_tmp13_ = _tmp12_->arg;
				_tmp14_ = g_list_nth_data (_tmp13_, list_index);
				return_char = (gchar) ((gintptr) _tmp14_);
				if (!(((gint) return_char) != 0)) {
					break;
				}
				_tmp15_ = list_index;
				list_index = _tmp15_ + 1;
				_tmp16_ = g_strnfill ((gsize) 1, return_char);
				_g_free0 (ret);
				ret = _tmp16_;
				result = ret;
				_g_free0 (name);
				return result;
			}
			_g_free0 (ret);
		}
	}
	result = NULL;
	_g_free0 (name);
	return result;
}

static gchar*
dh_out_dhutil_compeuntry_func_static (const gchar* str,
                                      gint state)
{
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = dh_out_dhutil_compeuntry_func (str, state);
	result = _tmp0_;
	return result;
}

void
dh_out_read_and_output (DhOut* self,
                        const gchar* tip_message,
                        const gchar* gettext_package,
                        DhArgInfo* arg,
                        DhValidator* validator,
                        gboolean get_array,
                        GValue* result)
{
	GValue _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (tip_message != NULL);
	g_return_if_fail (gettext_package != NULL);
	dh_out_read_and_output_custom (self, NULL, NULL, tip_message, gettext_package, arg, validator, get_array, TRUE, &_tmp0_);
	*result = _tmp0_;
	return;
}

static gpointer
_g_object_ref0 (gpointer self)
{
	return self ? g_object_ref (self) : NULL;
}

static gchar*
__readline (const gchar* prompt)
{
	void* cstr = NULL;
	void* _tmp0_;
	void* _tmp1_;
	gchar* str = NULL;
	void* _tmp2_;
	gchar* _tmp3_;
	void* _tmp4_;
	gchar* result;
	_tmp0_ = readline (prompt);
	cstr = _tmp0_;
	_tmp1_ = cstr;
	if (_tmp1_ == NULL) {
		result = NULL;
		return result;
	}
	_tmp2_ = cstr;
	_tmp3_ = g_strdup ((const gchar*) _tmp2_);
	str = _tmp3_;
	_tmp4_ = cstr;
	free (_tmp4_);
	result = str;
	return result;
}

static gchar
string_get (const gchar* self,
            glong index)
{
	gchar _tmp0_;
	gchar result;
	g_return_val_if_fail (self != NULL, '\0');
	_tmp0_ = ((gchar*) self)[index];
	result = _tmp0_;
	return result;
}

static gint64
int64_parse (const gchar* str,
             guint _base)
{
	gint64 result;
	g_return_val_if_fail (str != NULL, 0LL);
	result = g_ascii_strtoll (str, NULL, _base);
	return result;
}

static guint64
uint64_parse (const gchar* str,
              guint _base)
{
	guint64 result;
	g_return_val_if_fail (str != NULL, 0ULL);
	result = g_ascii_strtoull (str, NULL, _base);
	return result;
}

static gboolean
int64_try_parse (const gchar* str,
                 gint64* _result_,
                 const gchar** unparsed,
                 guint _base)
{
	gint64 _vala__result_ = 0LL;
	const gchar* _vala_unparsed = NULL;
	gchar* endptr = NULL;
	gchar* _tmp0_ = NULL;
	gint64 _tmp1_;
	gchar* _tmp2_;
	gint _tmp3_;
	gint _tmp4_;
	gboolean result;
	g_return_val_if_fail (str != NULL, FALSE);
	errno = 0;
	_tmp1_ = g_ascii_strtoll (str, &_tmp0_, _base);
	endptr = _tmp0_;
	_vala__result_ = _tmp1_;
	_tmp2_ = endptr;
	_tmp3_ = strlen (str);
	_tmp4_ = _tmp3_;
	if (_tmp2_ == (((gchar*) str) + _tmp4_)) {
		gboolean _tmp5_ = FALSE;
		_vala_unparsed = "";
		if (errno != ERANGE) {
			_tmp5_ = errno != EINVAL;
		} else {
			_tmp5_ = FALSE;
		}
		result = _tmp5_;
		if (_result_) {
			*_result_ = _vala__result_;
		}
		if (unparsed) {
			*unparsed = _vala_unparsed;
		}
		return result;
	} else {
		gchar* _tmp6_;
		_tmp6_ = endptr;
		_vala_unparsed = (const gchar*) _tmp6_;
		result = FALSE;
		if (_result_) {
			*_result_ = _vala__result_;
		}
		if (unparsed) {
			*unparsed = _vala_unparsed;
		}
		return result;
	}
}

void
dh_out_read_and_output_custom (DhOut* self,
                               DhLineinFunc func,
                               gpointer func_target,
                               const gchar* tip_message,
                               const gchar* gettext_package,
                               DhArgInfo* arg,
                               DhValidator* validator,
                               gboolean get_array,
                               gboolean use_readline,
                               GValue* result)
{
	g_return_if_fail (self != NULL);
	g_return_if_fail (tip_message != NULL);
	g_return_if_fail (gettext_package != NULL);
	dh_out_init_readline (self);
	while (TRUE) {
		DhArgInfo* _tmp0_;
		gchar* str = NULL;
		const gchar* _tmp14_;
		_tmp0_ = _g_object_ref0 (arg);
		_g_object_unref0 (dh_out_info);
		dh_out_info = _tmp0_;
		if (use_readline) {
			gchar* prompt = NULL;
			gchar* _tmp1_;
			gboolean _tmp2_ = FALSE;
			const gchar* _tmp11_;
			gchar* _tmp12_;
			_tmp1_ = g_strdup (gettext (tip_message));
			prompt = _tmp1_;
			if (self->priv->show_opt) {
				_tmp2_ = arg != NULL;
			} else {
				_tmp2_ = FALSE;
			}
			if (_tmp2_) {
				const gchar* _tmp3_;
				gchar* _tmp4_;
				const gchar* _tmp5_;
				gchar* _tmp6_;
				gchar* _tmp7_;
				gchar* _tmp8_;
				const gchar* _tmp9_;
				gchar* _tmp10_;
				_tmp3_ = prompt;
				_tmp4_ = g_strconcat (_tmp3_, " ", NULL);
				_g_free0 (prompt);
				prompt = _tmp4_;
				_tmp5_ = prompt;
				_tmp6_ = dh_out_get_opt (self, arg);
				_tmp7_ = _tmp6_;
				_tmp8_ = g_strconcat (_tmp5_, _tmp7_, NULL);
				_g_free0 (prompt);
				prompt = _tmp8_;
				_g_free0 (_tmp7_);
				_tmp9_ = prompt;
				_tmp10_ = g_strconcat (_tmp9_, ": ", NULL);
				_g_free0 (prompt);
				prompt = _tmp10_;
			}
			_tmp11_ = prompt;
			_tmp12_ = __readline (_tmp11_);
			_g_free0 (str);
			str = _tmp12_;
			_g_free0 (prompt);
		} else {
			gchar* _tmp13_;
			g_print ("%s", g_dgettext (gettext_package, tip_message));
			_tmp13_ = func (NULL, func_target);
			_g_free0 (str);
			str = _tmp13_;
		}
		_tmp14_ = str;
		if (_tmp14_ == NULL) {
			GValue _tmp15_ = {0};
			g_signal_emit (self, dh_out_signals[DH_OUT_SIG_EOF_SIGNAL], 0);
			g_value_init (&_tmp15_, G_TYPE_GTYPE);
			g_value_set_gtype (&_tmp15_, G_TYPE_NONE);
			*result = _tmp15_;
			_g_free0 (str);
			return;
		} else {
			const gchar* _tmp16_;
			_tmp16_ = str;
			if (((gint) string_get (_tmp16_, (glong) 0)) != 0) {
				const gchar* _tmp17_;
				_tmp17_ = str;
				add_history (_tmp17_);
			}
			if (arg != NULL) {
				const gchar* _tmp18_;
				gchar* _tmp19_;
				gchar* _tmp20_;
				gboolean _tmp21_;
				_tmp18_ = str;
				_tmp19_ = dh_out_remove_blank (self, _tmp18_);
				_tmp20_ = _tmp19_;
				_tmp21_ = g_regex_match_simple ("^\\?$", _tmp20_, 0, 0);
				_g_free0 (_tmp20_);
				if (_tmp21_) {
					gchar* _tmp22_;
					gchar* _tmp23_;
					_tmp22_ = dh_arg_info_help_message (arg, gettext_package);
					_tmp23_ = _tmp22_;
					g_print ("%s", _tmp23_);
					_g_free0 (_tmp23_);
					_g_free0 (str);
					continue;
				} else {
					if (self->priv->match_string) {
						gchar* ret = NULL;
						const gchar* _tmp24_;
						gchar* _tmp25_;
						gchar* _tmp26_;
						gchar* _tmp27_;
						gchar* _tmp28_;
						const gchar* _tmp29_;
						_tmp24_ = str;
						_tmp25_ = dh_out_remove_blank (self, _tmp24_);
						_tmp26_ = _tmp25_;
						_tmp27_ = dh_arg_info_match_string (arg, _tmp26_);
						_tmp28_ = _tmp27_;
						_g_free0 (_tmp26_);
						ret = _tmp28_;
						_tmp29_ = ret;
						if (_tmp29_ != NULL) {
							GValue _tmp30_ = {0};
							g_value_init (&_tmp30_, G_TYPE_STRING);
							g_value_take_string (&_tmp30_, ret);
							*result = _tmp30_;
							_g_free0 (str);
							return;
						}
						_g_free0 (ret);
					} else {
						gchar ret = '\0';
						const gchar* _tmp31_;
						gchar* _tmp32_;
						gchar* _tmp33_;
						gchar _tmp34_;
						_tmp31_ = str;
						_tmp32_ = dh_out_remove_blank (self, _tmp31_);
						_tmp33_ = _tmp32_;
						_tmp34_ = dh_arg_info_match_char (arg, _tmp33_);
						_g_free0 (_tmp33_);
						ret = _tmp34_;
						if (((gint) ret) != 0) {
							GValue _tmp35_ = {0};
							g_value_init (&_tmp35_, G_TYPE_CHAR);
							g_value_set_schar (&_tmp35_, ret);
							*result = _tmp35_;
							_g_free0 (str);
							return;
						}
					}
				}
			}
			if (validator != NULL) {
				const gchar* _tmp36_;
				gchar* _tmp37_;
				_tmp36_ = str;
				_tmp37_ = dh_out_remove_blank (self, _tmp36_);
				_g_free0 (str);
				str = _tmp37_;
				if (G_TYPE_FROM_INSTANCE ((GObject*) validator) == TYPE_DH_INT_VALIDATOR) {
					DhIntValidator* int_validator = NULL;
					DhIntValidator* _tmp38_;
					const gchar* _tmp39_;
					_tmp38_ = _g_object_ref0 (IS_DH_INT_VALIDATOR (validator) ? ((DhIntValidator*) validator) : NULL);
					int_validator = _tmp38_;
					_tmp39_ = str;
					if (g_regex_match_simple ("^[\\-|\\+]?[0-9]+$", _tmp39_, 0, 0)) {
						gint64 ret = 0LL;
						const gchar* _tmp40_;
						DhIntValidator* _tmp41_;
						_tmp40_ = str;
						ret = int64_parse (_tmp40_, (guint) 10);
						_tmp41_ = int_validator;
						if (dh_validator_in_field ((DhValidator*) _tmp41_, &ret)) {
							GValue _tmp42_ = {0};
							g_value_init (&_tmp42_, G_TYPE_INT64);
							g_value_set_int64 (&_tmp42_, ret);
							*result = _tmp42_;
							_g_object_unref0 (int_validator);
							_g_free0 (str);
							return;
						}
					}
					_g_object_unref0 (int_validator);
				} else {
					if (G_TYPE_FROM_INSTANCE ((GObject*) validator) == TYPE_DH_UINT_VALIDATOR) {
						DhUIntValidator* uint_validator = NULL;
						DhUIntValidator* _tmp43_;
						const gchar* _tmp44_;
						_tmp43_ = _g_object_ref0 (IS_DH_UINT_VALIDATOR (validator) ? ((DhUIntValidator*) validator) : NULL);
						uint_validator = _tmp43_;
						_tmp44_ = str;
						if (g_regex_match_simple ("^[\\+]?[0-9]+$", _tmp44_, 0, 0)) {
							guint64 ret = 0ULL;
							const gchar* _tmp45_;
							DhUIntValidator* _tmp46_;
							_tmp45_ = str;
							ret = uint64_parse (_tmp45_, (guint) 10);
							_tmp46_ = uint_validator;
							if (dh_validator_in_field ((DhValidator*) _tmp46_, &ret)) {
								GValue _tmp47_ = {0};
								g_value_init (&_tmp47_, G_TYPE_UINT64);
								g_value_set_uint64 (&_tmp47_, ret);
								*result = _tmp47_;
								_g_object_unref0 (uint_validator);
								_g_free0 (str);
								return;
							}
						}
						_g_object_unref0 (uint_validator);
					} else {
						if (G_TYPE_FROM_INSTANCE ((GObject*) validator) == TYPE_DH_DOUBLE_VALIDATOR) {
							DhDoubleValidator* double_validator = NULL;
							DhDoubleValidator* _tmp48_;
							gchar* end_str = NULL;
							gdouble ret = 0.0;
							const gchar* _tmp49_;
							const gchar* _tmp50_ = NULL;
							gdouble _tmp51_;
							gchar* _tmp52_;
							const gchar* _tmp53_;
							_tmp48_ = _g_object_ref0 (IS_DH_DOUBLE_VALIDATOR (validator) ? ((DhDoubleValidator*) validator) : NULL);
							double_validator = _tmp48_;
							_tmp49_ = str;
							_tmp51_ = g_ascii_strtod (_tmp49_, &_tmp50_);
							_g_free0 (end_str);
							_tmp52_ = g_strdup (_tmp50_);
							end_str = _tmp52_;
							ret = _tmp51_;
							_tmp53_ = end_str;
							if (g_strcmp0 (_tmp53_, "") == 0) {
								DhDoubleValidator* _tmp54_;
								_tmp54_ = double_validator;
								if (dh_validator_in_field ((DhValidator*) _tmp54_, &ret)) {
									GValue _tmp55_ = {0};
									g_value_init (&_tmp55_, G_TYPE_DOUBLE);
									g_value_set_double (&_tmp55_, ret);
									*result = _tmp55_;
									_g_free0 (end_str);
									_g_object_unref0 (double_validator);
									_g_free0 (str);
									return;
								}
							}
							_g_free0 (end_str);
							_g_object_unref0 (double_validator);
						} else {
							if (G_TYPE_FROM_INSTANCE ((GObject*) validator) == TYPE_DH_REGEX_VALIDATOR) {
								DhRegexValidator* regex_validator = NULL;
								DhRegexValidator* _tmp56_;
								DhRegexValidator* _tmp57_;
								const gchar* _tmp58_;
								_tmp56_ = _g_object_ref0 (IS_DH_REGEX_VALIDATOR (validator) ? ((DhRegexValidator*) validator) : NULL);
								regex_validator = _tmp56_;
								_tmp57_ = regex_validator;
								_tmp58_ = str;
								if (dh_validator_in_field ((DhValidator*) _tmp57_, _tmp58_)) {
									GValue _tmp59_ = {0};
									g_value_init (&_tmp59_, G_TYPE_STRING);
									g_value_take_string (&_tmp59_, str);
									*result = _tmp59_;
									_g_object_unref0 (regex_validator);
									return;
								}
								_g_object_unref0 (regex_validator);
							} else {
								if (G_TYPE_FROM_INSTANCE ((GObject*) validator) == TYPE_DH_MATCH_VALIDATOR) {
									DhMatchValidator* match_validator = NULL;
									DhMatchValidator* _tmp60_;
									DhMatchValidator* _tmp61_;
									const gchar* _tmp62_;
									_tmp60_ = _g_object_ref0 (IS_DH_MATCH_VALIDATOR (validator) ? ((DhMatchValidator*) validator) : NULL);
									match_validator = _tmp60_;
									_tmp61_ = match_validator;
									_tmp62_ = str;
									if (dh_validator_in_field ((DhValidator*) _tmp61_, _tmp62_)) {
										GValue _tmp63_ = {0};
										g_value_init (&_tmp63_, G_TYPE_STRING);
										g_value_take_string (&_tmp63_, str);
										*result = _tmp63_;
										_g_object_unref0 (match_validator);
										return;
									}
									_g_object_unref0 (match_validator);
								} else {
									if (G_TYPE_FROM_INSTANCE ((GObject*) validator) == TYPE_DH_INT_ARRAY_VALIDATOR) {
										DhIntArrayValidator* iav = NULL;
										DhIntArrayValidator* _tmp64_;
										GList* ret = NULL;
										gchar** after_str = NULL;
										const gchar* _tmp65_;
										DhIntArrayValidator* _tmp66_;
										const gchar* _tmp67_;
										gchar** _tmp68_;
										gchar** _tmp69_;
										gint after_str_length1;
										gint _after_str_size_;
										gboolean success = FALSE;
										_tmp64_ = _g_object_ref0 (IS_DH_INT_ARRAY_VALIDATOR (validator) ? ((DhIntArrayValidator*) validator) : NULL);
										iav = _tmp64_;
										ret = NULL;
										_tmp65_ = str;
										_tmp66_ = iav;
										_tmp67_ = _tmp66_->split_str;
										_tmp69_ = _tmp68_ = g_strsplit (_tmp65_, _tmp67_, 0);
										after_str = _tmp69_;
										after_str_length1 = _vala_array_length (_tmp68_);
										_after_str_size_ = after_str_length1;
										success = TRUE;
										{
											gint i = 0;
											i = 0;
											{
												gboolean _tmp70_ = FALSE;
												_tmp70_ = TRUE;
												while (TRUE) {
													gchar** _tmp72_;
													gint _tmp72__length1;
													gint64 temp = 0LL;
													gchar** _tmp73_;
													gint _tmp73__length1;
													const gchar* _tmp74_;
													gint64 _tmp75_ = 0LL;
													gboolean _tmp76_;
													if (!_tmp70_) {
														gint _tmp71_;
														_tmp71_ = i;
														i = _tmp71_ + 1;
													}
													_tmp70_ = FALSE;
													_tmp72_ = after_str;
													_tmp72__length1 = after_str_length1;
													if (!(i < _tmp72__length1)) {
														break;
													}
													_tmp73_ = after_str;
													_tmp73__length1 = after_str_length1;
													_tmp74_ = _tmp73_[i];
													_tmp76_ = int64_try_parse (_tmp74_, &_tmp75_, NULL, (guint) 0);
													temp = _tmp75_;
													if (_tmp76_) {
														gint64* _tmp77_;
														_tmp77_ = __int64_dup0 (&temp);
														ret = g_list_append (ret, _tmp77_);
													} else {
														success = FALSE;
														break;
													}
												}
											}
										}
										if (success) {
											DhIntArrayValidator* _tmp78_;
											GList* _tmp79_;
											_tmp78_ = iav;
											_tmp79_ = ret;
											if (dh_validator_in_field ((DhValidator*) _tmp78_, _tmp79_)) {
												GValue _tmp80_ = {0};
												g_value_init (&_tmp80_, G_TYPE_POINTER);
												g_value_set_pointer (&_tmp80_, ret);
												*result = _tmp80_;
												after_str = (_vala_array_free (after_str, after_str_length1, (GDestroyNotify) g_free), NULL);
												_g_object_unref0 (iav);
												_g_free0 (str);
												return;
											}
										}
										after_str = (_vala_array_free (after_str, after_str_length1, (GDestroyNotify) g_free), NULL);
										(ret == NULL) ? NULL : (ret = (_g_list_free__g_free0_ (ret), NULL));
										_g_object_unref0 (iav);
									}
								}
							}
						}
					}
				}
			} else {
				if (self->priv->output_str_while_nov) {
					GValue _tmp81_ = {0};
					g_value_init (&_tmp81_, G_TYPE_STRING);
					g_value_take_string (&_tmp81_, str);
					*result = _tmp81_;
					return;
				}
			}
			g_print ("Unsuccess!\n");
		}
		_g_free0 (str);
	}
}

void
dh_out_read_and_output_as_int_custom (DhOut* self,
                                      DhLineinFunc func,
                                      gpointer func_target,
                                      const gchar* tip_message,
                                      const gchar* gettext_package,
                                      DhArgInfo* arg,
                                      gint64 min,
                                      gint64 max,
                                      gboolean get_array,
                                      gboolean use_readline,
                                      GValue* result)
{
	DhIntValidator* validator = NULL;
	DhIntValidator* _tmp0_;
	GValue _tmp1_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (tip_message != NULL);
	g_return_if_fail (gettext_package != NULL);
	_tmp0_ = dh_int_validator_new (min, max);
	validator = _tmp0_;
	dh_out_read_and_output_custom (self, func, func_target, tip_message, gettext_package, arg, (DhValidator*) validator, get_array, use_readline, &_tmp1_);
	*result = _tmp1_;
	_g_object_unref0 (validator);
	return;
}

void
dh_out_read_and_output_as_int (DhOut* self,
                               const gchar* tip_message,
                               const gchar* gettext_package,
                               DhArgInfo* arg,
                               gint64 min,
                               gint64 max,
                               gboolean get_array,
                               GValue* result)
{
	GValue _tmp0_ = {0};
	g_return_if_fail (self != NULL);
	g_return_if_fail (tip_message != NULL);
	g_return_if_fail (gettext_package != NULL);
	dh_out_read_and_output_as_int_custom (self, NULL, NULL, tip_message, gettext_package, arg, min, max, get_array, TRUE, &_tmp0_);
	*result = _tmp0_;
	return;
}

static gchar*
string_strip (const gchar* self)
{
	gchar* _result_ = NULL;
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = g_strdup (self);
	_result_ = _tmp0_;
	g_strstrip (_result_);
	result = _result_;
	return result;
}

static gchar*
dh_out_remove_blank (DhOut* self,
                     const gchar* str)
{
	gchar* _tmp0_;
	gchar* result;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (str != NULL, NULL);
	_tmp0_ = string_strip (str);
	result = _tmp0_;
	return result;
}

DhOut*
dh_out_construct (GType object_type)
{
	DhOut * self = NULL;
	self = (DhOut*) g_object_new (object_type, NULL);
	return self;
}

DhOut*
dh_out_new (void)
{
	return dh_out_construct (TYPE_DH_OUT);
}

static void
dh_out_class_init (DhOutClass * klass,
                   gpointer klass_data)
{
	dh_out_parent_class = g_type_class_peek_parent (klass);
	g_type_class_adjust_private_offset (klass, &DhOut_private_offset);
	G_OBJECT_CLASS (klass)->finalize = dh_out_finalize;
	dh_out_signals[DH_OUT_SIG_EOF_SIGNAL] = g_signal_new ("sig-eof", TYPE_DH_OUT, G_SIGNAL_RUN_LAST, 0, NULL, NULL, g_cclosure_marshal_VOID__VOID, G_TYPE_NONE, 0);
}

static void
dh_out_instance_init (DhOut * self,
                      gpointer klass)
{
	self->priv = dh_out_get_instance_private (self);
	self->priv->match_string = FALSE;
	self->priv->output_str_while_nov = TRUE;
	self->priv->show_opt = FALSE;
}

static void
dh_out_finalize (GObject * obj)
{
	DhOut * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_DH_OUT, DhOut);
	G_OBJECT_CLASS (dh_out_parent_class)->finalize (obj);
}

static GType
dh_out_get_type_once (void)
{
	static const GTypeInfo g_define_type_info = { sizeof (DhOutClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) dh_out_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (DhOut), 0, (GInstanceInitFunc) dh_out_instance_init, NULL };
	GType dh_out_type_id;
	dh_out_type_id = g_type_register_static (G_TYPE_OBJECT, "DhOut", &g_define_type_info, 0);
	DhOut_private_offset = g_type_add_instance_private (dh_out_type_id, sizeof (DhOutPrivate));
	return dh_out_type_id;
}

GType
dh_out_get_type (void)
{
	static volatile gsize dh_out_type_id__once = 0;
	if (g_once_init_enter (&dh_out_type_id__once)) {
		GType dh_out_type_id;
		dh_out_type_id = dh_out_get_type_once ();
		g_once_init_leave (&dh_out_type_id__once, dh_out_type_id);
	}
	return dh_out_type_id__once;
}

static void
_vala_array_destroy (gpointer array,
                     gssize array_length,
                     GDestroyNotify destroy_func)
{
	if ((array != NULL) && (destroy_func != NULL)) {
		gssize i;
		for (i = 0; i < array_length; i = i + 1) {
			if (((gpointer*) array)[i] != NULL) {
				destroy_func (((gpointer*) array)[i]);
			}
		}
	}
}

static void
_vala_array_free (gpointer array,
                  gssize array_length,
                  GDestroyNotify destroy_func)
{
	_vala_array_destroy (array, array_length, destroy_func);
	g_free (array);
}

static gssize
_vala_array_length (gpointer array)
{
	gssize length;
	length = 0;
	if (array) {
		while (((gpointer*) array)[length]) {
			length++;
		}
	}
	return length;
}

